// This file is generated by rust-protobuf 2.27.1. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `networking/v1beta1/destination_rule.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_27_1;

#[derive(PartialEq,Clone,Default)]
pub struct DestinationRule {
    // message fields
    pub host: ::std::string::String,
    pub traffic_policy: ::protobuf::SingularPtrField<TrafficPolicy>,
    pub subsets: ::protobuf::RepeatedField<Subset>,
    pub export_to: ::protobuf::RepeatedField<::std::string::String>,
    pub workload_selector: ::protobuf::SingularPtrField<super::selector::WorkloadSelector>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DestinationRule {
    fn default() -> &'a DestinationRule {
        <DestinationRule as ::protobuf::Message>::default_instance()
    }
}

impl DestinationRule {
    pub fn new() -> DestinationRule {
        ::std::default::Default::default()
    }

    // string host = 1;


    pub fn get_host(&self) -> &str {
        &self.host
    }
    pub fn clear_host(&mut self) {
        self.host.clear();
    }

    // Param is passed by value, moved
    pub fn set_host(&mut self, v: ::std::string::String) {
        self.host = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_host(&mut self) -> &mut ::std::string::String {
        &mut self.host
    }

    // Take field
    pub fn take_host(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.host, ::std::string::String::new())
    }

    // .istio.networking.v1beta1.TrafficPolicy traffic_policy = 2;


    pub fn get_traffic_policy(&self) -> &TrafficPolicy {
        self.traffic_policy.as_ref().unwrap_or_else(|| <TrafficPolicy as ::protobuf::Message>::default_instance())
    }
    pub fn clear_traffic_policy(&mut self) {
        self.traffic_policy.clear();
    }

    pub fn has_traffic_policy(&self) -> bool {
        self.traffic_policy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_traffic_policy(&mut self, v: TrafficPolicy) {
        self.traffic_policy = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_traffic_policy(&mut self) -> &mut TrafficPolicy {
        if self.traffic_policy.is_none() {
            self.traffic_policy.set_default();
        }
        self.traffic_policy.as_mut().unwrap()
    }

    // Take field
    pub fn take_traffic_policy(&mut self) -> TrafficPolicy {
        self.traffic_policy.take().unwrap_or_else(|| TrafficPolicy::new())
    }

    // repeated .istio.networking.v1beta1.Subset subsets = 3;


    pub fn get_subsets(&self) -> &[Subset] {
        &self.subsets
    }
    pub fn clear_subsets(&mut self) {
        self.subsets.clear();
    }

    // Param is passed by value, moved
    pub fn set_subsets(&mut self, v: ::protobuf::RepeatedField<Subset>) {
        self.subsets = v;
    }

    // Mutable pointer to the field.
    pub fn mut_subsets(&mut self) -> &mut ::protobuf::RepeatedField<Subset> {
        &mut self.subsets
    }

    // Take field
    pub fn take_subsets(&mut self) -> ::protobuf::RepeatedField<Subset> {
        ::std::mem::replace(&mut self.subsets, ::protobuf::RepeatedField::new())
    }

    // repeated string export_to = 4;


    pub fn get_export_to(&self) -> &[::std::string::String] {
        &self.export_to
    }
    pub fn clear_export_to(&mut self) {
        self.export_to.clear();
    }

    // Param is passed by value, moved
    pub fn set_export_to(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.export_to = v;
    }

    // Mutable pointer to the field.
    pub fn mut_export_to(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.export_to
    }

    // Take field
    pub fn take_export_to(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.export_to, ::protobuf::RepeatedField::new())
    }

    // .istio.type.v1beta1.WorkloadSelector workload_selector = 5;


    pub fn get_workload_selector(&self) -> &super::selector::WorkloadSelector {
        self.workload_selector.as_ref().unwrap_or_else(|| <super::selector::WorkloadSelector as ::protobuf::Message>::default_instance())
    }
    pub fn clear_workload_selector(&mut self) {
        self.workload_selector.clear();
    }

    pub fn has_workload_selector(&self) -> bool {
        self.workload_selector.is_some()
    }

    // Param is passed by value, moved
    pub fn set_workload_selector(&mut self, v: super::selector::WorkloadSelector) {
        self.workload_selector = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_workload_selector(&mut self) -> &mut super::selector::WorkloadSelector {
        if self.workload_selector.is_none() {
            self.workload_selector.set_default();
        }
        self.workload_selector.as_mut().unwrap()
    }

    // Take field
    pub fn take_workload_selector(&mut self) -> super::selector::WorkloadSelector {
        self.workload_selector.take().unwrap_or_else(|| super::selector::WorkloadSelector::new())
    }
}

impl ::protobuf::Message for DestinationRule {
    fn is_initialized(&self) -> bool {
        for v in &self.traffic_policy {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.subsets {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.workload_selector {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.host)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.traffic_policy)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.subsets)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.export_to)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.workload_selector)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.host.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.host);
        }
        if let Some(ref v) = self.traffic_policy.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.subsets {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.export_to {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        if let Some(ref v) = self.workload_selector.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.host.is_empty() {
            os.write_string(1, &self.host)?;
        }
        if let Some(ref v) = self.traffic_policy.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.subsets {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.export_to {
            os.write_string(4, &v)?;
        };
        if let Some(ref v) = self.workload_selector.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DestinationRule {
        DestinationRule::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "host",
                |m: &DestinationRule| { &m.host },
                |m: &mut DestinationRule| { &mut m.host },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TrafficPolicy>>(
                "traffic_policy",
                |m: &DestinationRule| { &m.traffic_policy },
                |m: &mut DestinationRule| { &mut m.traffic_policy },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Subset>>(
                "subsets",
                |m: &DestinationRule| { &m.subsets },
                |m: &mut DestinationRule| { &mut m.subsets },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "export_to",
                |m: &DestinationRule| { &m.export_to },
                |m: &mut DestinationRule| { &mut m.export_to },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::selector::WorkloadSelector>>(
                "workload_selector",
                |m: &DestinationRule| { &m.workload_selector },
                |m: &mut DestinationRule| { &mut m.workload_selector },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DestinationRule>(
                "DestinationRule",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DestinationRule {
        static instance: ::protobuf::rt::LazyV2<DestinationRule> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DestinationRule::new)
    }
}

impl ::protobuf::Clear for DestinationRule {
    fn clear(&mut self) {
        self.host.clear();
        self.traffic_policy.clear();
        self.subsets.clear();
        self.export_to.clear();
        self.workload_selector.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DestinationRule {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DestinationRule {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TrafficPolicy {
    // message fields
    pub load_balancer: ::protobuf::SingularPtrField<LoadBalancerSettings>,
    pub connection_pool: ::protobuf::SingularPtrField<ConnectionPoolSettings>,
    pub outlier_detection: ::protobuf::SingularPtrField<OutlierDetection>,
    pub tls: ::protobuf::SingularPtrField<ClientTLSSettings>,
    pub port_level_settings: ::protobuf::RepeatedField<TrafficPolicy_PortTrafficPolicy>,
    pub tunnel: ::protobuf::SingularPtrField<TrafficPolicy_TunnelSettings>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TrafficPolicy {
    fn default() -> &'a TrafficPolicy {
        <TrafficPolicy as ::protobuf::Message>::default_instance()
    }
}

impl TrafficPolicy {
    pub fn new() -> TrafficPolicy {
        ::std::default::Default::default()
    }

    // .istio.networking.v1beta1.LoadBalancerSettings load_balancer = 1;


    pub fn get_load_balancer(&self) -> &LoadBalancerSettings {
        self.load_balancer.as_ref().unwrap_or_else(|| <LoadBalancerSettings as ::protobuf::Message>::default_instance())
    }
    pub fn clear_load_balancer(&mut self) {
        self.load_balancer.clear();
    }

    pub fn has_load_balancer(&self) -> bool {
        self.load_balancer.is_some()
    }

    // Param is passed by value, moved
    pub fn set_load_balancer(&mut self, v: LoadBalancerSettings) {
        self.load_balancer = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_load_balancer(&mut self) -> &mut LoadBalancerSettings {
        if self.load_balancer.is_none() {
            self.load_balancer.set_default();
        }
        self.load_balancer.as_mut().unwrap()
    }

    // Take field
    pub fn take_load_balancer(&mut self) -> LoadBalancerSettings {
        self.load_balancer.take().unwrap_or_else(|| LoadBalancerSettings::new())
    }

    // .istio.networking.v1beta1.ConnectionPoolSettings connection_pool = 2;


    pub fn get_connection_pool(&self) -> &ConnectionPoolSettings {
        self.connection_pool.as_ref().unwrap_or_else(|| <ConnectionPoolSettings as ::protobuf::Message>::default_instance())
    }
    pub fn clear_connection_pool(&mut self) {
        self.connection_pool.clear();
    }

    pub fn has_connection_pool(&self) -> bool {
        self.connection_pool.is_some()
    }

    // Param is passed by value, moved
    pub fn set_connection_pool(&mut self, v: ConnectionPoolSettings) {
        self.connection_pool = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_connection_pool(&mut self) -> &mut ConnectionPoolSettings {
        if self.connection_pool.is_none() {
            self.connection_pool.set_default();
        }
        self.connection_pool.as_mut().unwrap()
    }

    // Take field
    pub fn take_connection_pool(&mut self) -> ConnectionPoolSettings {
        self.connection_pool.take().unwrap_or_else(|| ConnectionPoolSettings::new())
    }

    // .istio.networking.v1beta1.OutlierDetection outlier_detection = 3;


    pub fn get_outlier_detection(&self) -> &OutlierDetection {
        self.outlier_detection.as_ref().unwrap_or_else(|| <OutlierDetection as ::protobuf::Message>::default_instance())
    }
    pub fn clear_outlier_detection(&mut self) {
        self.outlier_detection.clear();
    }

    pub fn has_outlier_detection(&self) -> bool {
        self.outlier_detection.is_some()
    }

    // Param is passed by value, moved
    pub fn set_outlier_detection(&mut self, v: OutlierDetection) {
        self.outlier_detection = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_outlier_detection(&mut self) -> &mut OutlierDetection {
        if self.outlier_detection.is_none() {
            self.outlier_detection.set_default();
        }
        self.outlier_detection.as_mut().unwrap()
    }

    // Take field
    pub fn take_outlier_detection(&mut self) -> OutlierDetection {
        self.outlier_detection.take().unwrap_or_else(|| OutlierDetection::new())
    }

    // .istio.networking.v1beta1.ClientTLSSettings tls = 4;


    pub fn get_tls(&self) -> &ClientTLSSettings {
        self.tls.as_ref().unwrap_or_else(|| <ClientTLSSettings as ::protobuf::Message>::default_instance())
    }
    pub fn clear_tls(&mut self) {
        self.tls.clear();
    }

    pub fn has_tls(&self) -> bool {
        self.tls.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tls(&mut self, v: ClientTLSSettings) {
        self.tls = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tls(&mut self) -> &mut ClientTLSSettings {
        if self.tls.is_none() {
            self.tls.set_default();
        }
        self.tls.as_mut().unwrap()
    }

    // Take field
    pub fn take_tls(&mut self) -> ClientTLSSettings {
        self.tls.take().unwrap_or_else(|| ClientTLSSettings::new())
    }

    // repeated .istio.networking.v1beta1.TrafficPolicy.PortTrafficPolicy port_level_settings = 5;


    pub fn get_port_level_settings(&self) -> &[TrafficPolicy_PortTrafficPolicy] {
        &self.port_level_settings
    }
    pub fn clear_port_level_settings(&mut self) {
        self.port_level_settings.clear();
    }

    // Param is passed by value, moved
    pub fn set_port_level_settings(&mut self, v: ::protobuf::RepeatedField<TrafficPolicy_PortTrafficPolicy>) {
        self.port_level_settings = v;
    }

    // Mutable pointer to the field.
    pub fn mut_port_level_settings(&mut self) -> &mut ::protobuf::RepeatedField<TrafficPolicy_PortTrafficPolicy> {
        &mut self.port_level_settings
    }

    // Take field
    pub fn take_port_level_settings(&mut self) -> ::protobuf::RepeatedField<TrafficPolicy_PortTrafficPolicy> {
        ::std::mem::replace(&mut self.port_level_settings, ::protobuf::RepeatedField::new())
    }

    // .istio.networking.v1beta1.TrafficPolicy.TunnelSettings tunnel = 6;


    pub fn get_tunnel(&self) -> &TrafficPolicy_TunnelSettings {
        self.tunnel.as_ref().unwrap_or_else(|| <TrafficPolicy_TunnelSettings as ::protobuf::Message>::default_instance())
    }
    pub fn clear_tunnel(&mut self) {
        self.tunnel.clear();
    }

    pub fn has_tunnel(&self) -> bool {
        self.tunnel.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tunnel(&mut self, v: TrafficPolicy_TunnelSettings) {
        self.tunnel = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tunnel(&mut self) -> &mut TrafficPolicy_TunnelSettings {
        if self.tunnel.is_none() {
            self.tunnel.set_default();
        }
        self.tunnel.as_mut().unwrap()
    }

    // Take field
    pub fn take_tunnel(&mut self) -> TrafficPolicy_TunnelSettings {
        self.tunnel.take().unwrap_or_else(|| TrafficPolicy_TunnelSettings::new())
    }
}

impl ::protobuf::Message for TrafficPolicy {
    fn is_initialized(&self) -> bool {
        for v in &self.load_balancer {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.connection_pool {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.outlier_detection {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.tls {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.port_level_settings {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.tunnel {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.load_balancer)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.connection_pool)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.outlier_detection)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.tls)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.port_level_settings)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.tunnel)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.load_balancer.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.connection_pool.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.outlier_detection.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.tls.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.port_level_settings {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.tunnel.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.load_balancer.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.connection_pool.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.outlier_detection.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.tls.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.port_level_settings {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.tunnel.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TrafficPolicy {
        TrafficPolicy::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LoadBalancerSettings>>(
                "load_balancer",
                |m: &TrafficPolicy| { &m.load_balancer },
                |m: &mut TrafficPolicy| { &mut m.load_balancer },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ConnectionPoolSettings>>(
                "connection_pool",
                |m: &TrafficPolicy| { &m.connection_pool },
                |m: &mut TrafficPolicy| { &mut m.connection_pool },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OutlierDetection>>(
                "outlier_detection",
                |m: &TrafficPolicy| { &m.outlier_detection },
                |m: &mut TrafficPolicy| { &mut m.outlier_detection },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ClientTLSSettings>>(
                "tls",
                |m: &TrafficPolicy| { &m.tls },
                |m: &mut TrafficPolicy| { &mut m.tls },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TrafficPolicy_PortTrafficPolicy>>(
                "port_level_settings",
                |m: &TrafficPolicy| { &m.port_level_settings },
                |m: &mut TrafficPolicy| { &mut m.port_level_settings },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TrafficPolicy_TunnelSettings>>(
                "tunnel",
                |m: &TrafficPolicy| { &m.tunnel },
                |m: &mut TrafficPolicy| { &mut m.tunnel },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TrafficPolicy>(
                "TrafficPolicy",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TrafficPolicy {
        static instance: ::protobuf::rt::LazyV2<TrafficPolicy> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TrafficPolicy::new)
    }
}

impl ::protobuf::Clear for TrafficPolicy {
    fn clear(&mut self) {
        self.load_balancer.clear();
        self.connection_pool.clear();
        self.outlier_detection.clear();
        self.tls.clear();
        self.port_level_settings.clear();
        self.tunnel.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TrafficPolicy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TrafficPolicy {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TrafficPolicy_PortTrafficPolicy {
    // message fields
    pub port: ::protobuf::SingularPtrField<super::virtual_service::PortSelector>,
    pub load_balancer: ::protobuf::SingularPtrField<LoadBalancerSettings>,
    pub connection_pool: ::protobuf::SingularPtrField<ConnectionPoolSettings>,
    pub outlier_detection: ::protobuf::SingularPtrField<OutlierDetection>,
    pub tls: ::protobuf::SingularPtrField<ClientTLSSettings>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TrafficPolicy_PortTrafficPolicy {
    fn default() -> &'a TrafficPolicy_PortTrafficPolicy {
        <TrafficPolicy_PortTrafficPolicy as ::protobuf::Message>::default_instance()
    }
}

impl TrafficPolicy_PortTrafficPolicy {
    pub fn new() -> TrafficPolicy_PortTrafficPolicy {
        ::std::default::Default::default()
    }

    // .istio.networking.v1beta1.PortSelector port = 1;


    pub fn get_port(&self) -> &super::virtual_service::PortSelector {
        self.port.as_ref().unwrap_or_else(|| <super::virtual_service::PortSelector as ::protobuf::Message>::default_instance())
    }
    pub fn clear_port(&mut self) {
        self.port.clear();
    }

    pub fn has_port(&self) -> bool {
        self.port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_port(&mut self, v: super::virtual_service::PortSelector) {
        self.port = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_port(&mut self) -> &mut super::virtual_service::PortSelector {
        if self.port.is_none() {
            self.port.set_default();
        }
        self.port.as_mut().unwrap()
    }

    // Take field
    pub fn take_port(&mut self) -> super::virtual_service::PortSelector {
        self.port.take().unwrap_or_else(|| super::virtual_service::PortSelector::new())
    }

    // .istio.networking.v1beta1.LoadBalancerSettings load_balancer = 2;


    pub fn get_load_balancer(&self) -> &LoadBalancerSettings {
        self.load_balancer.as_ref().unwrap_or_else(|| <LoadBalancerSettings as ::protobuf::Message>::default_instance())
    }
    pub fn clear_load_balancer(&mut self) {
        self.load_balancer.clear();
    }

    pub fn has_load_balancer(&self) -> bool {
        self.load_balancer.is_some()
    }

    // Param is passed by value, moved
    pub fn set_load_balancer(&mut self, v: LoadBalancerSettings) {
        self.load_balancer = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_load_balancer(&mut self) -> &mut LoadBalancerSettings {
        if self.load_balancer.is_none() {
            self.load_balancer.set_default();
        }
        self.load_balancer.as_mut().unwrap()
    }

    // Take field
    pub fn take_load_balancer(&mut self) -> LoadBalancerSettings {
        self.load_balancer.take().unwrap_or_else(|| LoadBalancerSettings::new())
    }

    // .istio.networking.v1beta1.ConnectionPoolSettings connection_pool = 3;


    pub fn get_connection_pool(&self) -> &ConnectionPoolSettings {
        self.connection_pool.as_ref().unwrap_or_else(|| <ConnectionPoolSettings as ::protobuf::Message>::default_instance())
    }
    pub fn clear_connection_pool(&mut self) {
        self.connection_pool.clear();
    }

    pub fn has_connection_pool(&self) -> bool {
        self.connection_pool.is_some()
    }

    // Param is passed by value, moved
    pub fn set_connection_pool(&mut self, v: ConnectionPoolSettings) {
        self.connection_pool = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_connection_pool(&mut self) -> &mut ConnectionPoolSettings {
        if self.connection_pool.is_none() {
            self.connection_pool.set_default();
        }
        self.connection_pool.as_mut().unwrap()
    }

    // Take field
    pub fn take_connection_pool(&mut self) -> ConnectionPoolSettings {
        self.connection_pool.take().unwrap_or_else(|| ConnectionPoolSettings::new())
    }

    // .istio.networking.v1beta1.OutlierDetection outlier_detection = 4;


    pub fn get_outlier_detection(&self) -> &OutlierDetection {
        self.outlier_detection.as_ref().unwrap_or_else(|| <OutlierDetection as ::protobuf::Message>::default_instance())
    }
    pub fn clear_outlier_detection(&mut self) {
        self.outlier_detection.clear();
    }

    pub fn has_outlier_detection(&self) -> bool {
        self.outlier_detection.is_some()
    }

    // Param is passed by value, moved
    pub fn set_outlier_detection(&mut self, v: OutlierDetection) {
        self.outlier_detection = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_outlier_detection(&mut self) -> &mut OutlierDetection {
        if self.outlier_detection.is_none() {
            self.outlier_detection.set_default();
        }
        self.outlier_detection.as_mut().unwrap()
    }

    // Take field
    pub fn take_outlier_detection(&mut self) -> OutlierDetection {
        self.outlier_detection.take().unwrap_or_else(|| OutlierDetection::new())
    }

    // .istio.networking.v1beta1.ClientTLSSettings tls = 5;


    pub fn get_tls(&self) -> &ClientTLSSettings {
        self.tls.as_ref().unwrap_or_else(|| <ClientTLSSettings as ::protobuf::Message>::default_instance())
    }
    pub fn clear_tls(&mut self) {
        self.tls.clear();
    }

    pub fn has_tls(&self) -> bool {
        self.tls.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tls(&mut self, v: ClientTLSSettings) {
        self.tls = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tls(&mut self) -> &mut ClientTLSSettings {
        if self.tls.is_none() {
            self.tls.set_default();
        }
        self.tls.as_mut().unwrap()
    }

    // Take field
    pub fn take_tls(&mut self) -> ClientTLSSettings {
        self.tls.take().unwrap_or_else(|| ClientTLSSettings::new())
    }
}

impl ::protobuf::Message for TrafficPolicy_PortTrafficPolicy {
    fn is_initialized(&self) -> bool {
        for v in &self.port {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.load_balancer {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.connection_pool {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.outlier_detection {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.tls {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.port)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.load_balancer)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.connection_pool)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.outlier_detection)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.tls)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.port.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.load_balancer.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.connection_pool.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.outlier_detection.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.tls.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.port.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.load_balancer.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.connection_pool.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.outlier_detection.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.tls.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TrafficPolicy_PortTrafficPolicy {
        TrafficPolicy_PortTrafficPolicy::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::virtual_service::PortSelector>>(
                "port",
                |m: &TrafficPolicy_PortTrafficPolicy| { &m.port },
                |m: &mut TrafficPolicy_PortTrafficPolicy| { &mut m.port },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LoadBalancerSettings>>(
                "load_balancer",
                |m: &TrafficPolicy_PortTrafficPolicy| { &m.load_balancer },
                |m: &mut TrafficPolicy_PortTrafficPolicy| { &mut m.load_balancer },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ConnectionPoolSettings>>(
                "connection_pool",
                |m: &TrafficPolicy_PortTrafficPolicy| { &m.connection_pool },
                |m: &mut TrafficPolicy_PortTrafficPolicy| { &mut m.connection_pool },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OutlierDetection>>(
                "outlier_detection",
                |m: &TrafficPolicy_PortTrafficPolicy| { &m.outlier_detection },
                |m: &mut TrafficPolicy_PortTrafficPolicy| { &mut m.outlier_detection },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ClientTLSSettings>>(
                "tls",
                |m: &TrafficPolicy_PortTrafficPolicy| { &m.tls },
                |m: &mut TrafficPolicy_PortTrafficPolicy| { &mut m.tls },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TrafficPolicy_PortTrafficPolicy>(
                "TrafficPolicy.PortTrafficPolicy",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TrafficPolicy_PortTrafficPolicy {
        static instance: ::protobuf::rt::LazyV2<TrafficPolicy_PortTrafficPolicy> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TrafficPolicy_PortTrafficPolicy::new)
    }
}

impl ::protobuf::Clear for TrafficPolicy_PortTrafficPolicy {
    fn clear(&mut self) {
        self.port.clear();
        self.load_balancer.clear();
        self.connection_pool.clear();
        self.outlier_detection.clear();
        self.tls.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TrafficPolicy_PortTrafficPolicy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TrafficPolicy_PortTrafficPolicy {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TrafficPolicy_TunnelSettings {
    // message fields
    pub protocol: ::std::string::String,
    pub target_host: ::std::string::String,
    pub target_port: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TrafficPolicy_TunnelSettings {
    fn default() -> &'a TrafficPolicy_TunnelSettings {
        <TrafficPolicy_TunnelSettings as ::protobuf::Message>::default_instance()
    }
}

impl TrafficPolicy_TunnelSettings {
    pub fn new() -> TrafficPolicy_TunnelSettings {
        ::std::default::Default::default()
    }

    // string protocol = 1;


    pub fn get_protocol(&self) -> &str {
        &self.protocol
    }
    pub fn clear_protocol(&mut self) {
        self.protocol.clear();
    }

    // Param is passed by value, moved
    pub fn set_protocol(&mut self, v: ::std::string::String) {
        self.protocol = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_protocol(&mut self) -> &mut ::std::string::String {
        &mut self.protocol
    }

    // Take field
    pub fn take_protocol(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.protocol, ::std::string::String::new())
    }

    // string target_host = 2;


    pub fn get_target_host(&self) -> &str {
        &self.target_host
    }
    pub fn clear_target_host(&mut self) {
        self.target_host.clear();
    }

    // Param is passed by value, moved
    pub fn set_target_host(&mut self, v: ::std::string::String) {
        self.target_host = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_target_host(&mut self) -> &mut ::std::string::String {
        &mut self.target_host
    }

    // Take field
    pub fn take_target_host(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.target_host, ::std::string::String::new())
    }

    // uint32 target_port = 3;


    pub fn get_target_port(&self) -> u32 {
        self.target_port
    }
    pub fn clear_target_port(&mut self) {
        self.target_port = 0;
    }

    // Param is passed by value, moved
    pub fn set_target_port(&mut self, v: u32) {
        self.target_port = v;
    }
}

impl ::protobuf::Message for TrafficPolicy_TunnelSettings {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.protocol)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.target_host)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.target_port = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.protocol.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.protocol);
        }
        if !self.target_host.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.target_host);
        }
        if self.target_port != 0 {
            my_size += ::protobuf::rt::value_size(3, self.target_port, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.protocol.is_empty() {
            os.write_string(1, &self.protocol)?;
        }
        if !self.target_host.is_empty() {
            os.write_string(2, &self.target_host)?;
        }
        if self.target_port != 0 {
            os.write_uint32(3, self.target_port)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TrafficPolicy_TunnelSettings {
        TrafficPolicy_TunnelSettings::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "protocol",
                |m: &TrafficPolicy_TunnelSettings| { &m.protocol },
                |m: &mut TrafficPolicy_TunnelSettings| { &mut m.protocol },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "target_host",
                |m: &TrafficPolicy_TunnelSettings| { &m.target_host },
                |m: &mut TrafficPolicy_TunnelSettings| { &mut m.target_host },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "target_port",
                |m: &TrafficPolicy_TunnelSettings| { &m.target_port },
                |m: &mut TrafficPolicy_TunnelSettings| { &mut m.target_port },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TrafficPolicy_TunnelSettings>(
                "TrafficPolicy.TunnelSettings",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TrafficPolicy_TunnelSettings {
        static instance: ::protobuf::rt::LazyV2<TrafficPolicy_TunnelSettings> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TrafficPolicy_TunnelSettings::new)
    }
}

impl ::protobuf::Clear for TrafficPolicy_TunnelSettings {
    fn clear(&mut self) {
        self.protocol.clear();
        self.target_host.clear();
        self.target_port = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TrafficPolicy_TunnelSettings {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TrafficPolicy_TunnelSettings {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Subset {
    // message fields
    pub name: ::std::string::String,
    pub labels: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    pub traffic_policy: ::protobuf::SingularPtrField<TrafficPolicy>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Subset {
    fn default() -> &'a Subset {
        <Subset as ::protobuf::Message>::default_instance()
    }
}

impl Subset {
    pub fn new() -> Subset {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // repeated .istio.networking.v1beta1.Subset.LabelsEntry labels = 2;


    pub fn get_labels(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.labels
    }
    pub fn clear_labels(&mut self) {
        self.labels.clear();
    }

    // Param is passed by value, moved
    pub fn set_labels(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.labels = v;
    }

    // Mutable pointer to the field.
    pub fn mut_labels(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.labels
    }

    // Take field
    pub fn take_labels(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.labels, ::std::collections::HashMap::new())
    }

    // .istio.networking.v1beta1.TrafficPolicy traffic_policy = 3;


    pub fn get_traffic_policy(&self) -> &TrafficPolicy {
        self.traffic_policy.as_ref().unwrap_or_else(|| <TrafficPolicy as ::protobuf::Message>::default_instance())
    }
    pub fn clear_traffic_policy(&mut self) {
        self.traffic_policy.clear();
    }

    pub fn has_traffic_policy(&self) -> bool {
        self.traffic_policy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_traffic_policy(&mut self, v: TrafficPolicy) {
        self.traffic_policy = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_traffic_policy(&mut self) -> &mut TrafficPolicy {
        if self.traffic_policy.is_none() {
            self.traffic_policy.set_default();
        }
        self.traffic_policy.as_mut().unwrap()
    }

    // Take field
    pub fn take_traffic_policy(&mut self) -> TrafficPolicy {
        self.traffic_policy.take().unwrap_or_else(|| TrafficPolicy::new())
    }
}

impl ::protobuf::Message for Subset {
    fn is_initialized(&self) -> bool {
        for v in &self.traffic_policy {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.labels)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.traffic_policy)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(2, &self.labels);
        if let Some(ref v) = self.traffic_policy.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(2, &self.labels, os)?;
        if let Some(ref v) = self.traffic_policy.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Subset {
        Subset::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &Subset| { &m.name },
                |m: &mut Subset| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                "labels",
                |m: &Subset| { &m.labels },
                |m: &mut Subset| { &mut m.labels },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TrafficPolicy>>(
                "traffic_policy",
                |m: &Subset| { &m.traffic_policy },
                |m: &mut Subset| { &mut m.traffic_policy },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Subset>(
                "Subset",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Subset {
        static instance: ::protobuf::rt::LazyV2<Subset> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Subset::new)
    }
}

impl ::protobuf::Clear for Subset {
    fn clear(&mut self) {
        self.name.clear();
        self.labels.clear();
        self.traffic_policy.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Subset {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Subset {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LoadBalancerSettings {
    // message fields
    pub locality_lb_setting: ::protobuf::SingularPtrField<LocalityLoadBalancerSetting>,
    pub warmup_duration_secs: ::protobuf::SingularPtrField<::protobuf::well_known_types::Duration>,
    // message oneof groups
    pub lb_policy: ::std::option::Option<LoadBalancerSettings_oneof_lb_policy>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LoadBalancerSettings {
    fn default() -> &'a LoadBalancerSettings {
        <LoadBalancerSettings as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum LoadBalancerSettings_oneof_lb_policy {
    simple(LoadBalancerSettings_SimpleLB),
    consistent_hash(LoadBalancerSettings_ConsistentHashLB),
}

impl LoadBalancerSettings {
    pub fn new() -> LoadBalancerSettings {
        ::std::default::Default::default()
    }

    // .istio.networking.v1beta1.LoadBalancerSettings.SimpleLB simple = 1;


    pub fn get_simple(&self) -> LoadBalancerSettings_SimpleLB {
        match self.lb_policy {
            ::std::option::Option::Some(LoadBalancerSettings_oneof_lb_policy::simple(v)) => v,
            _ => LoadBalancerSettings_SimpleLB::UNSPECIFIED,
        }
    }
    pub fn clear_simple(&mut self) {
        self.lb_policy = ::std::option::Option::None;
    }

    pub fn has_simple(&self) -> bool {
        match self.lb_policy {
            ::std::option::Option::Some(LoadBalancerSettings_oneof_lb_policy::simple(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_simple(&mut self, v: LoadBalancerSettings_SimpleLB) {
        self.lb_policy = ::std::option::Option::Some(LoadBalancerSettings_oneof_lb_policy::simple(v))
    }

    // .istio.networking.v1beta1.LoadBalancerSettings.ConsistentHashLB consistent_hash = 2;


    pub fn get_consistent_hash(&self) -> &LoadBalancerSettings_ConsistentHashLB {
        match self.lb_policy {
            ::std::option::Option::Some(LoadBalancerSettings_oneof_lb_policy::consistent_hash(ref v)) => v,
            _ => <LoadBalancerSettings_ConsistentHashLB as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_consistent_hash(&mut self) {
        self.lb_policy = ::std::option::Option::None;
    }

    pub fn has_consistent_hash(&self) -> bool {
        match self.lb_policy {
            ::std::option::Option::Some(LoadBalancerSettings_oneof_lb_policy::consistent_hash(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_consistent_hash(&mut self, v: LoadBalancerSettings_ConsistentHashLB) {
        self.lb_policy = ::std::option::Option::Some(LoadBalancerSettings_oneof_lb_policy::consistent_hash(v))
    }

    // Mutable pointer to the field.
    pub fn mut_consistent_hash(&mut self) -> &mut LoadBalancerSettings_ConsistentHashLB {
        if let ::std::option::Option::Some(LoadBalancerSettings_oneof_lb_policy::consistent_hash(_)) = self.lb_policy {
        } else {
            self.lb_policy = ::std::option::Option::Some(LoadBalancerSettings_oneof_lb_policy::consistent_hash(LoadBalancerSettings_ConsistentHashLB::new()));
        }
        match self.lb_policy {
            ::std::option::Option::Some(LoadBalancerSettings_oneof_lb_policy::consistent_hash(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_consistent_hash(&mut self) -> LoadBalancerSettings_ConsistentHashLB {
        if self.has_consistent_hash() {
            match self.lb_policy.take() {
                ::std::option::Option::Some(LoadBalancerSettings_oneof_lb_policy::consistent_hash(v)) => v,
                _ => panic!(),
            }
        } else {
            LoadBalancerSettings_ConsistentHashLB::new()
        }
    }

    // .istio.networking.v1beta1.LocalityLoadBalancerSetting locality_lb_setting = 3;


    pub fn get_locality_lb_setting(&self) -> &LocalityLoadBalancerSetting {
        self.locality_lb_setting.as_ref().unwrap_or_else(|| <LocalityLoadBalancerSetting as ::protobuf::Message>::default_instance())
    }
    pub fn clear_locality_lb_setting(&mut self) {
        self.locality_lb_setting.clear();
    }

    pub fn has_locality_lb_setting(&self) -> bool {
        self.locality_lb_setting.is_some()
    }

    // Param is passed by value, moved
    pub fn set_locality_lb_setting(&mut self, v: LocalityLoadBalancerSetting) {
        self.locality_lb_setting = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_locality_lb_setting(&mut self) -> &mut LocalityLoadBalancerSetting {
        if self.locality_lb_setting.is_none() {
            self.locality_lb_setting.set_default();
        }
        self.locality_lb_setting.as_mut().unwrap()
    }

    // Take field
    pub fn take_locality_lb_setting(&mut self) -> LocalityLoadBalancerSetting {
        self.locality_lb_setting.take().unwrap_or_else(|| LocalityLoadBalancerSetting::new())
    }

    // .google.protobuf.Duration warmup_duration_secs = 4;


    pub fn get_warmup_duration_secs(&self) -> &::protobuf::well_known_types::Duration {
        self.warmup_duration_secs.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Duration as ::protobuf::Message>::default_instance())
    }
    pub fn clear_warmup_duration_secs(&mut self) {
        self.warmup_duration_secs.clear();
    }

    pub fn has_warmup_duration_secs(&self) -> bool {
        self.warmup_duration_secs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_warmup_duration_secs(&mut self, v: ::protobuf::well_known_types::Duration) {
        self.warmup_duration_secs = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_warmup_duration_secs(&mut self) -> &mut ::protobuf::well_known_types::Duration {
        if self.warmup_duration_secs.is_none() {
            self.warmup_duration_secs.set_default();
        }
        self.warmup_duration_secs.as_mut().unwrap()
    }

    // Take field
    pub fn take_warmup_duration_secs(&mut self) -> ::protobuf::well_known_types::Duration {
        self.warmup_duration_secs.take().unwrap_or_else(|| ::protobuf::well_known_types::Duration::new())
    }
}

impl ::protobuf::Message for LoadBalancerSettings {
    fn is_initialized(&self) -> bool {
        if let Some(LoadBalancerSettings_oneof_lb_policy::consistent_hash(ref v)) = self.lb_policy {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.locality_lb_setting {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.warmup_duration_secs {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.lb_policy = ::std::option::Option::Some(LoadBalancerSettings_oneof_lb_policy::simple(is.read_enum()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.lb_policy = ::std::option::Option::Some(LoadBalancerSettings_oneof_lb_policy::consistent_hash(is.read_message()?));
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.locality_lb_setting)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.warmup_duration_secs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.locality_lb_setting.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.warmup_duration_secs.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let ::std::option::Option::Some(ref v) = self.lb_policy {
            match v {
                &LoadBalancerSettings_oneof_lb_policy::simple(v) => {
                    my_size += ::protobuf::rt::enum_size(1, v);
                },
                &LoadBalancerSettings_oneof_lb_policy::consistent_hash(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.locality_lb_setting.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.warmup_duration_secs.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let ::std::option::Option::Some(ref v) = self.lb_policy {
            match v {
                &LoadBalancerSettings_oneof_lb_policy::simple(v) => {
                    os.write_enum(1, ::protobuf::ProtobufEnum::value(&v))?;
                },
                &LoadBalancerSettings_oneof_lb_policy::consistent_hash(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LoadBalancerSettings {
        LoadBalancerSettings::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_enum_accessor::<_, LoadBalancerSettings_SimpleLB>(
                "simple",
                LoadBalancerSettings::has_simple,
                LoadBalancerSettings::get_simple,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, LoadBalancerSettings_ConsistentHashLB>(
                "consistent_hash",
                LoadBalancerSettings::has_consistent_hash,
                LoadBalancerSettings::get_consistent_hash,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LocalityLoadBalancerSetting>>(
                "locality_lb_setting",
                |m: &LoadBalancerSettings| { &m.locality_lb_setting },
                |m: &mut LoadBalancerSettings| { &mut m.locality_lb_setting },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Duration>>(
                "warmup_duration_secs",
                |m: &LoadBalancerSettings| { &m.warmup_duration_secs },
                |m: &mut LoadBalancerSettings| { &mut m.warmup_duration_secs },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LoadBalancerSettings>(
                "LoadBalancerSettings",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LoadBalancerSettings {
        static instance: ::protobuf::rt::LazyV2<LoadBalancerSettings> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LoadBalancerSettings::new)
    }
}

impl ::protobuf::Clear for LoadBalancerSettings {
    fn clear(&mut self) {
        self.lb_policy = ::std::option::Option::None;
        self.lb_policy = ::std::option::Option::None;
        self.locality_lb_setting.clear();
        self.warmup_duration_secs.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LoadBalancerSettings {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LoadBalancerSettings {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LoadBalancerSettings_ConsistentHashLB {
    // message fields
    pub minimum_ring_size: u64,
    // message oneof groups
    pub hash_key: ::std::option::Option<LoadBalancerSettings_ConsistentHashLB_oneof_hash_key>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LoadBalancerSettings_ConsistentHashLB {
    fn default() -> &'a LoadBalancerSettings_ConsistentHashLB {
        <LoadBalancerSettings_ConsistentHashLB as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum LoadBalancerSettings_ConsistentHashLB_oneof_hash_key {
    http_header_name(::std::string::String),
    http_cookie(LoadBalancerSettings_ConsistentHashLB_HTTPCookie),
    use_source_ip(bool),
    http_query_parameter_name(::std::string::String),
}

impl LoadBalancerSettings_ConsistentHashLB {
    pub fn new() -> LoadBalancerSettings_ConsistentHashLB {
        ::std::default::Default::default()
    }

    // string http_header_name = 1;


    pub fn get_http_header_name(&self) -> &str {
        match self.hash_key {
            ::std::option::Option::Some(LoadBalancerSettings_ConsistentHashLB_oneof_hash_key::http_header_name(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_http_header_name(&mut self) {
        self.hash_key = ::std::option::Option::None;
    }

    pub fn has_http_header_name(&self) -> bool {
        match self.hash_key {
            ::std::option::Option::Some(LoadBalancerSettings_ConsistentHashLB_oneof_hash_key::http_header_name(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_http_header_name(&mut self, v: ::std::string::String) {
        self.hash_key = ::std::option::Option::Some(LoadBalancerSettings_ConsistentHashLB_oneof_hash_key::http_header_name(v))
    }

    // Mutable pointer to the field.
    pub fn mut_http_header_name(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(LoadBalancerSettings_ConsistentHashLB_oneof_hash_key::http_header_name(_)) = self.hash_key {
        } else {
            self.hash_key = ::std::option::Option::Some(LoadBalancerSettings_ConsistentHashLB_oneof_hash_key::http_header_name(::std::string::String::new()));
        }
        match self.hash_key {
            ::std::option::Option::Some(LoadBalancerSettings_ConsistentHashLB_oneof_hash_key::http_header_name(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_http_header_name(&mut self) -> ::std::string::String {
        if self.has_http_header_name() {
            match self.hash_key.take() {
                ::std::option::Option::Some(LoadBalancerSettings_ConsistentHashLB_oneof_hash_key::http_header_name(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // .istio.networking.v1beta1.LoadBalancerSettings.ConsistentHashLB.HTTPCookie http_cookie = 2;


    pub fn get_http_cookie(&self) -> &LoadBalancerSettings_ConsistentHashLB_HTTPCookie {
        match self.hash_key {
            ::std::option::Option::Some(LoadBalancerSettings_ConsistentHashLB_oneof_hash_key::http_cookie(ref v)) => v,
            _ => <LoadBalancerSettings_ConsistentHashLB_HTTPCookie as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_http_cookie(&mut self) {
        self.hash_key = ::std::option::Option::None;
    }

    pub fn has_http_cookie(&self) -> bool {
        match self.hash_key {
            ::std::option::Option::Some(LoadBalancerSettings_ConsistentHashLB_oneof_hash_key::http_cookie(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_http_cookie(&mut self, v: LoadBalancerSettings_ConsistentHashLB_HTTPCookie) {
        self.hash_key = ::std::option::Option::Some(LoadBalancerSettings_ConsistentHashLB_oneof_hash_key::http_cookie(v))
    }

    // Mutable pointer to the field.
    pub fn mut_http_cookie(&mut self) -> &mut LoadBalancerSettings_ConsistentHashLB_HTTPCookie {
        if let ::std::option::Option::Some(LoadBalancerSettings_ConsistentHashLB_oneof_hash_key::http_cookie(_)) = self.hash_key {
        } else {
            self.hash_key = ::std::option::Option::Some(LoadBalancerSettings_ConsistentHashLB_oneof_hash_key::http_cookie(LoadBalancerSettings_ConsistentHashLB_HTTPCookie::new()));
        }
        match self.hash_key {
            ::std::option::Option::Some(LoadBalancerSettings_ConsistentHashLB_oneof_hash_key::http_cookie(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_http_cookie(&mut self) -> LoadBalancerSettings_ConsistentHashLB_HTTPCookie {
        if self.has_http_cookie() {
            match self.hash_key.take() {
                ::std::option::Option::Some(LoadBalancerSettings_ConsistentHashLB_oneof_hash_key::http_cookie(v)) => v,
                _ => panic!(),
            }
        } else {
            LoadBalancerSettings_ConsistentHashLB_HTTPCookie::new()
        }
    }

    // bool use_source_ip = 3;


    pub fn get_use_source_ip(&self) -> bool {
        match self.hash_key {
            ::std::option::Option::Some(LoadBalancerSettings_ConsistentHashLB_oneof_hash_key::use_source_ip(v)) => v,
            _ => false,
        }
    }
    pub fn clear_use_source_ip(&mut self) {
        self.hash_key = ::std::option::Option::None;
    }

    pub fn has_use_source_ip(&self) -> bool {
        match self.hash_key {
            ::std::option::Option::Some(LoadBalancerSettings_ConsistentHashLB_oneof_hash_key::use_source_ip(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_use_source_ip(&mut self, v: bool) {
        self.hash_key = ::std::option::Option::Some(LoadBalancerSettings_ConsistentHashLB_oneof_hash_key::use_source_ip(v))
    }

    // string http_query_parameter_name = 5;


    pub fn get_http_query_parameter_name(&self) -> &str {
        match self.hash_key {
            ::std::option::Option::Some(LoadBalancerSettings_ConsistentHashLB_oneof_hash_key::http_query_parameter_name(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_http_query_parameter_name(&mut self) {
        self.hash_key = ::std::option::Option::None;
    }

    pub fn has_http_query_parameter_name(&self) -> bool {
        match self.hash_key {
            ::std::option::Option::Some(LoadBalancerSettings_ConsistentHashLB_oneof_hash_key::http_query_parameter_name(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_http_query_parameter_name(&mut self, v: ::std::string::String) {
        self.hash_key = ::std::option::Option::Some(LoadBalancerSettings_ConsistentHashLB_oneof_hash_key::http_query_parameter_name(v))
    }

    // Mutable pointer to the field.
    pub fn mut_http_query_parameter_name(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(LoadBalancerSettings_ConsistentHashLB_oneof_hash_key::http_query_parameter_name(_)) = self.hash_key {
        } else {
            self.hash_key = ::std::option::Option::Some(LoadBalancerSettings_ConsistentHashLB_oneof_hash_key::http_query_parameter_name(::std::string::String::new()));
        }
        match self.hash_key {
            ::std::option::Option::Some(LoadBalancerSettings_ConsistentHashLB_oneof_hash_key::http_query_parameter_name(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_http_query_parameter_name(&mut self) -> ::std::string::String {
        if self.has_http_query_parameter_name() {
            match self.hash_key.take() {
                ::std::option::Option::Some(LoadBalancerSettings_ConsistentHashLB_oneof_hash_key::http_query_parameter_name(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // uint64 minimum_ring_size = 4;


    pub fn get_minimum_ring_size(&self) -> u64 {
        self.minimum_ring_size
    }
    pub fn clear_minimum_ring_size(&mut self) {
        self.minimum_ring_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_minimum_ring_size(&mut self, v: u64) {
        self.minimum_ring_size = v;
    }
}

impl ::protobuf::Message for LoadBalancerSettings_ConsistentHashLB {
    fn is_initialized(&self) -> bool {
        if let Some(LoadBalancerSettings_ConsistentHashLB_oneof_hash_key::http_cookie(ref v)) = self.hash_key {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.hash_key = ::std::option::Option::Some(LoadBalancerSettings_ConsistentHashLB_oneof_hash_key::http_header_name(is.read_string()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.hash_key = ::std::option::Option::Some(LoadBalancerSettings_ConsistentHashLB_oneof_hash_key::http_cookie(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.hash_key = ::std::option::Option::Some(LoadBalancerSettings_ConsistentHashLB_oneof_hash_key::use_source_ip(is.read_bool()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.hash_key = ::std::option::Option::Some(LoadBalancerSettings_ConsistentHashLB_oneof_hash_key::http_query_parameter_name(is.read_string()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.minimum_ring_size = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.minimum_ring_size != 0 {
            my_size += ::protobuf::rt::value_size(4, self.minimum_ring_size, ::protobuf::wire_format::WireTypeVarint);
        }
        if let ::std::option::Option::Some(ref v) = self.hash_key {
            match v {
                &LoadBalancerSettings_ConsistentHashLB_oneof_hash_key::http_header_name(ref v) => {
                    my_size += ::protobuf::rt::string_size(1, &v);
                },
                &LoadBalancerSettings_ConsistentHashLB_oneof_hash_key::http_cookie(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &LoadBalancerSettings_ConsistentHashLB_oneof_hash_key::use_source_ip(v) => {
                    my_size += 2;
                },
                &LoadBalancerSettings_ConsistentHashLB_oneof_hash_key::http_query_parameter_name(ref v) => {
                    my_size += ::protobuf::rt::string_size(5, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.minimum_ring_size != 0 {
            os.write_uint64(4, self.minimum_ring_size)?;
        }
        if let ::std::option::Option::Some(ref v) = self.hash_key {
            match v {
                &LoadBalancerSettings_ConsistentHashLB_oneof_hash_key::http_header_name(ref v) => {
                    os.write_string(1, v)?;
                },
                &LoadBalancerSettings_ConsistentHashLB_oneof_hash_key::http_cookie(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &LoadBalancerSettings_ConsistentHashLB_oneof_hash_key::use_source_ip(v) => {
                    os.write_bool(3, v)?;
                },
                &LoadBalancerSettings_ConsistentHashLB_oneof_hash_key::http_query_parameter_name(ref v) => {
                    os.write_string(5, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LoadBalancerSettings_ConsistentHashLB {
        LoadBalancerSettings_ConsistentHashLB::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "http_header_name",
                LoadBalancerSettings_ConsistentHashLB::has_http_header_name,
                LoadBalancerSettings_ConsistentHashLB::get_http_header_name,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, LoadBalancerSettings_ConsistentHashLB_HTTPCookie>(
                "http_cookie",
                LoadBalancerSettings_ConsistentHashLB::has_http_cookie,
                LoadBalancerSettings_ConsistentHashLB::get_http_cookie,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor::<_>(
                "use_source_ip",
                LoadBalancerSettings_ConsistentHashLB::has_use_source_ip,
                LoadBalancerSettings_ConsistentHashLB::get_use_source_ip,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "http_query_parameter_name",
                LoadBalancerSettings_ConsistentHashLB::has_http_query_parameter_name,
                LoadBalancerSettings_ConsistentHashLB::get_http_query_parameter_name,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "minimum_ring_size",
                |m: &LoadBalancerSettings_ConsistentHashLB| { &m.minimum_ring_size },
                |m: &mut LoadBalancerSettings_ConsistentHashLB| { &mut m.minimum_ring_size },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LoadBalancerSettings_ConsistentHashLB>(
                "LoadBalancerSettings.ConsistentHashLB",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LoadBalancerSettings_ConsistentHashLB {
        static instance: ::protobuf::rt::LazyV2<LoadBalancerSettings_ConsistentHashLB> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LoadBalancerSettings_ConsistentHashLB::new)
    }
}

impl ::protobuf::Clear for LoadBalancerSettings_ConsistentHashLB {
    fn clear(&mut self) {
        self.hash_key = ::std::option::Option::None;
        self.hash_key = ::std::option::Option::None;
        self.hash_key = ::std::option::Option::None;
        self.hash_key = ::std::option::Option::None;
        self.minimum_ring_size = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LoadBalancerSettings_ConsistentHashLB {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LoadBalancerSettings_ConsistentHashLB {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LoadBalancerSettings_ConsistentHashLB_HTTPCookie {
    // message fields
    pub name: ::std::string::String,
    pub path: ::std::string::String,
    pub ttl: ::protobuf::SingularPtrField<::protobuf::well_known_types::Duration>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LoadBalancerSettings_ConsistentHashLB_HTTPCookie {
    fn default() -> &'a LoadBalancerSettings_ConsistentHashLB_HTTPCookie {
        <LoadBalancerSettings_ConsistentHashLB_HTTPCookie as ::protobuf::Message>::default_instance()
    }
}

impl LoadBalancerSettings_ConsistentHashLB_HTTPCookie {
    pub fn new() -> LoadBalancerSettings_ConsistentHashLB_HTTPCookie {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string path = 2;


    pub fn get_path(&self) -> &str {
        &self.path
    }
    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        &mut self.path
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.path, ::std::string::String::new())
    }

    // .google.protobuf.Duration ttl = 3;


    pub fn get_ttl(&self) -> &::protobuf::well_known_types::Duration {
        self.ttl.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Duration as ::protobuf::Message>::default_instance())
    }
    pub fn clear_ttl(&mut self) {
        self.ttl.clear();
    }

    pub fn has_ttl(&self) -> bool {
        self.ttl.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ttl(&mut self, v: ::protobuf::well_known_types::Duration) {
        self.ttl = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ttl(&mut self) -> &mut ::protobuf::well_known_types::Duration {
        if self.ttl.is_none() {
            self.ttl.set_default();
        }
        self.ttl.as_mut().unwrap()
    }

    // Take field
    pub fn take_ttl(&mut self) -> ::protobuf::well_known_types::Duration {
        self.ttl.take().unwrap_or_else(|| ::protobuf::well_known_types::Duration::new())
    }
}

impl ::protobuf::Message for LoadBalancerSettings_ConsistentHashLB_HTTPCookie {
    fn is_initialized(&self) -> bool {
        for v in &self.ttl {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.path)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.ttl)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if !self.path.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.path);
        }
        if let Some(ref v) = self.ttl.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.path.is_empty() {
            os.write_string(2, &self.path)?;
        }
        if let Some(ref v) = self.ttl.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LoadBalancerSettings_ConsistentHashLB_HTTPCookie {
        LoadBalancerSettings_ConsistentHashLB_HTTPCookie::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &LoadBalancerSettings_ConsistentHashLB_HTTPCookie| { &m.name },
                |m: &mut LoadBalancerSettings_ConsistentHashLB_HTTPCookie| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "path",
                |m: &LoadBalancerSettings_ConsistentHashLB_HTTPCookie| { &m.path },
                |m: &mut LoadBalancerSettings_ConsistentHashLB_HTTPCookie| { &mut m.path },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Duration>>(
                "ttl",
                |m: &LoadBalancerSettings_ConsistentHashLB_HTTPCookie| { &m.ttl },
                |m: &mut LoadBalancerSettings_ConsistentHashLB_HTTPCookie| { &mut m.ttl },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LoadBalancerSettings_ConsistentHashLB_HTTPCookie>(
                "LoadBalancerSettings.ConsistentHashLB.HTTPCookie",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LoadBalancerSettings_ConsistentHashLB_HTTPCookie {
        static instance: ::protobuf::rt::LazyV2<LoadBalancerSettings_ConsistentHashLB_HTTPCookie> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LoadBalancerSettings_ConsistentHashLB_HTTPCookie::new)
    }
}

impl ::protobuf::Clear for LoadBalancerSettings_ConsistentHashLB_HTTPCookie {
    fn clear(&mut self) {
        self.name.clear();
        self.path.clear();
        self.ttl.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LoadBalancerSettings_ConsistentHashLB_HTTPCookie {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LoadBalancerSettings_ConsistentHashLB_HTTPCookie {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum LoadBalancerSettings_SimpleLB {
    UNSPECIFIED = 0,
    LEAST_CONN = 1,
    RANDOM = 2,
    PASSTHROUGH = 3,
    ROUND_ROBIN = 4,
    LEAST_REQUEST = 5,
}

impl ::protobuf::ProtobufEnum for LoadBalancerSettings_SimpleLB {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<LoadBalancerSettings_SimpleLB> {
        match value {
            0 => ::std::option::Option::Some(LoadBalancerSettings_SimpleLB::UNSPECIFIED),
            1 => ::std::option::Option::Some(LoadBalancerSettings_SimpleLB::LEAST_CONN),
            2 => ::std::option::Option::Some(LoadBalancerSettings_SimpleLB::RANDOM),
            3 => ::std::option::Option::Some(LoadBalancerSettings_SimpleLB::PASSTHROUGH),
            4 => ::std::option::Option::Some(LoadBalancerSettings_SimpleLB::ROUND_ROBIN),
            5 => ::std::option::Option::Some(LoadBalancerSettings_SimpleLB::LEAST_REQUEST),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [LoadBalancerSettings_SimpleLB] = &[
            LoadBalancerSettings_SimpleLB::UNSPECIFIED,
            LoadBalancerSettings_SimpleLB::LEAST_CONN,
            LoadBalancerSettings_SimpleLB::RANDOM,
            LoadBalancerSettings_SimpleLB::PASSTHROUGH,
            LoadBalancerSettings_SimpleLB::ROUND_ROBIN,
            LoadBalancerSettings_SimpleLB::LEAST_REQUEST,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<LoadBalancerSettings_SimpleLB>("LoadBalancerSettings.SimpleLB", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for LoadBalancerSettings_SimpleLB {
}

impl ::std::default::Default for LoadBalancerSettings_SimpleLB {
    fn default() -> Self {
        LoadBalancerSettings_SimpleLB::UNSPECIFIED
    }
}

impl ::protobuf::reflect::ProtobufValue for LoadBalancerSettings_SimpleLB {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ConnectionPoolSettings {
    // message fields
    pub tcp: ::protobuf::SingularPtrField<ConnectionPoolSettings_TCPSettings>,
    pub http: ::protobuf::SingularPtrField<ConnectionPoolSettings_HTTPSettings>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ConnectionPoolSettings {
    fn default() -> &'a ConnectionPoolSettings {
        <ConnectionPoolSettings as ::protobuf::Message>::default_instance()
    }
}

impl ConnectionPoolSettings {
    pub fn new() -> ConnectionPoolSettings {
        ::std::default::Default::default()
    }

    // .istio.networking.v1beta1.ConnectionPoolSettings.TCPSettings tcp = 1;


    pub fn get_tcp(&self) -> &ConnectionPoolSettings_TCPSettings {
        self.tcp.as_ref().unwrap_or_else(|| <ConnectionPoolSettings_TCPSettings as ::protobuf::Message>::default_instance())
    }
    pub fn clear_tcp(&mut self) {
        self.tcp.clear();
    }

    pub fn has_tcp(&self) -> bool {
        self.tcp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tcp(&mut self, v: ConnectionPoolSettings_TCPSettings) {
        self.tcp = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tcp(&mut self) -> &mut ConnectionPoolSettings_TCPSettings {
        if self.tcp.is_none() {
            self.tcp.set_default();
        }
        self.tcp.as_mut().unwrap()
    }

    // Take field
    pub fn take_tcp(&mut self) -> ConnectionPoolSettings_TCPSettings {
        self.tcp.take().unwrap_or_else(|| ConnectionPoolSettings_TCPSettings::new())
    }

    // .istio.networking.v1beta1.ConnectionPoolSettings.HTTPSettings http = 2;


    pub fn get_http(&self) -> &ConnectionPoolSettings_HTTPSettings {
        self.http.as_ref().unwrap_or_else(|| <ConnectionPoolSettings_HTTPSettings as ::protobuf::Message>::default_instance())
    }
    pub fn clear_http(&mut self) {
        self.http.clear();
    }

    pub fn has_http(&self) -> bool {
        self.http.is_some()
    }

    // Param is passed by value, moved
    pub fn set_http(&mut self, v: ConnectionPoolSettings_HTTPSettings) {
        self.http = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_http(&mut self) -> &mut ConnectionPoolSettings_HTTPSettings {
        if self.http.is_none() {
            self.http.set_default();
        }
        self.http.as_mut().unwrap()
    }

    // Take field
    pub fn take_http(&mut self) -> ConnectionPoolSettings_HTTPSettings {
        self.http.take().unwrap_or_else(|| ConnectionPoolSettings_HTTPSettings::new())
    }
}

impl ::protobuf::Message for ConnectionPoolSettings {
    fn is_initialized(&self) -> bool {
        for v in &self.tcp {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.http {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.tcp)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.http)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.tcp.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.http.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.tcp.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.http.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ConnectionPoolSettings {
        ConnectionPoolSettings::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ConnectionPoolSettings_TCPSettings>>(
                "tcp",
                |m: &ConnectionPoolSettings| { &m.tcp },
                |m: &mut ConnectionPoolSettings| { &mut m.tcp },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ConnectionPoolSettings_HTTPSettings>>(
                "http",
                |m: &ConnectionPoolSettings| { &m.http },
                |m: &mut ConnectionPoolSettings| { &mut m.http },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ConnectionPoolSettings>(
                "ConnectionPoolSettings",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ConnectionPoolSettings {
        static instance: ::protobuf::rt::LazyV2<ConnectionPoolSettings> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ConnectionPoolSettings::new)
    }
}

impl ::protobuf::Clear for ConnectionPoolSettings {
    fn clear(&mut self) {
        self.tcp.clear();
        self.http.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ConnectionPoolSettings {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConnectionPoolSettings {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ConnectionPoolSettings_TCPSettings {
    // message fields
    pub max_connections: i32,
    pub connect_timeout: ::protobuf::SingularPtrField<::protobuf::well_known_types::Duration>,
    pub tcp_keepalive: ::protobuf::SingularPtrField<ConnectionPoolSettings_TCPSettings_TcpKeepalive>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ConnectionPoolSettings_TCPSettings {
    fn default() -> &'a ConnectionPoolSettings_TCPSettings {
        <ConnectionPoolSettings_TCPSettings as ::protobuf::Message>::default_instance()
    }
}

impl ConnectionPoolSettings_TCPSettings {
    pub fn new() -> ConnectionPoolSettings_TCPSettings {
        ::std::default::Default::default()
    }

    // int32 max_connections = 1;


    pub fn get_max_connections(&self) -> i32 {
        self.max_connections
    }
    pub fn clear_max_connections(&mut self) {
        self.max_connections = 0;
    }

    // Param is passed by value, moved
    pub fn set_max_connections(&mut self, v: i32) {
        self.max_connections = v;
    }

    // .google.protobuf.Duration connect_timeout = 2;


    pub fn get_connect_timeout(&self) -> &::protobuf::well_known_types::Duration {
        self.connect_timeout.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Duration as ::protobuf::Message>::default_instance())
    }
    pub fn clear_connect_timeout(&mut self) {
        self.connect_timeout.clear();
    }

    pub fn has_connect_timeout(&self) -> bool {
        self.connect_timeout.is_some()
    }

    // Param is passed by value, moved
    pub fn set_connect_timeout(&mut self, v: ::protobuf::well_known_types::Duration) {
        self.connect_timeout = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_connect_timeout(&mut self) -> &mut ::protobuf::well_known_types::Duration {
        if self.connect_timeout.is_none() {
            self.connect_timeout.set_default();
        }
        self.connect_timeout.as_mut().unwrap()
    }

    // Take field
    pub fn take_connect_timeout(&mut self) -> ::protobuf::well_known_types::Duration {
        self.connect_timeout.take().unwrap_or_else(|| ::protobuf::well_known_types::Duration::new())
    }

    // .istio.networking.v1beta1.ConnectionPoolSettings.TCPSettings.TcpKeepalive tcp_keepalive = 3;


    pub fn get_tcp_keepalive(&self) -> &ConnectionPoolSettings_TCPSettings_TcpKeepalive {
        self.tcp_keepalive.as_ref().unwrap_or_else(|| <ConnectionPoolSettings_TCPSettings_TcpKeepalive as ::protobuf::Message>::default_instance())
    }
    pub fn clear_tcp_keepalive(&mut self) {
        self.tcp_keepalive.clear();
    }

    pub fn has_tcp_keepalive(&self) -> bool {
        self.tcp_keepalive.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tcp_keepalive(&mut self, v: ConnectionPoolSettings_TCPSettings_TcpKeepalive) {
        self.tcp_keepalive = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tcp_keepalive(&mut self) -> &mut ConnectionPoolSettings_TCPSettings_TcpKeepalive {
        if self.tcp_keepalive.is_none() {
            self.tcp_keepalive.set_default();
        }
        self.tcp_keepalive.as_mut().unwrap()
    }

    // Take field
    pub fn take_tcp_keepalive(&mut self) -> ConnectionPoolSettings_TCPSettings_TcpKeepalive {
        self.tcp_keepalive.take().unwrap_or_else(|| ConnectionPoolSettings_TCPSettings_TcpKeepalive::new())
    }
}

impl ::protobuf::Message for ConnectionPoolSettings_TCPSettings {
    fn is_initialized(&self) -> bool {
        for v in &self.connect_timeout {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.tcp_keepalive {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.max_connections = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.connect_timeout)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.tcp_keepalive)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.max_connections != 0 {
            my_size += ::protobuf::rt::value_size(1, self.max_connections, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.connect_timeout.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.tcp_keepalive.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.max_connections != 0 {
            os.write_int32(1, self.max_connections)?;
        }
        if let Some(ref v) = self.connect_timeout.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.tcp_keepalive.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ConnectionPoolSettings_TCPSettings {
        ConnectionPoolSettings_TCPSettings::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "max_connections",
                |m: &ConnectionPoolSettings_TCPSettings| { &m.max_connections },
                |m: &mut ConnectionPoolSettings_TCPSettings| { &mut m.max_connections },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Duration>>(
                "connect_timeout",
                |m: &ConnectionPoolSettings_TCPSettings| { &m.connect_timeout },
                |m: &mut ConnectionPoolSettings_TCPSettings| { &mut m.connect_timeout },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ConnectionPoolSettings_TCPSettings_TcpKeepalive>>(
                "tcp_keepalive",
                |m: &ConnectionPoolSettings_TCPSettings| { &m.tcp_keepalive },
                |m: &mut ConnectionPoolSettings_TCPSettings| { &mut m.tcp_keepalive },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ConnectionPoolSettings_TCPSettings>(
                "ConnectionPoolSettings.TCPSettings",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ConnectionPoolSettings_TCPSettings {
        static instance: ::protobuf::rt::LazyV2<ConnectionPoolSettings_TCPSettings> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ConnectionPoolSettings_TCPSettings::new)
    }
}

impl ::protobuf::Clear for ConnectionPoolSettings_TCPSettings {
    fn clear(&mut self) {
        self.max_connections = 0;
        self.connect_timeout.clear();
        self.tcp_keepalive.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ConnectionPoolSettings_TCPSettings {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConnectionPoolSettings_TCPSettings {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ConnectionPoolSettings_TCPSettings_TcpKeepalive {
    // message fields
    pub probes: u32,
    pub time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Duration>,
    pub interval: ::protobuf::SingularPtrField<::protobuf::well_known_types::Duration>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ConnectionPoolSettings_TCPSettings_TcpKeepalive {
    fn default() -> &'a ConnectionPoolSettings_TCPSettings_TcpKeepalive {
        <ConnectionPoolSettings_TCPSettings_TcpKeepalive as ::protobuf::Message>::default_instance()
    }
}

impl ConnectionPoolSettings_TCPSettings_TcpKeepalive {
    pub fn new() -> ConnectionPoolSettings_TCPSettings_TcpKeepalive {
        ::std::default::Default::default()
    }

    // uint32 probes = 1;


    pub fn get_probes(&self) -> u32 {
        self.probes
    }
    pub fn clear_probes(&mut self) {
        self.probes = 0;
    }

    // Param is passed by value, moved
    pub fn set_probes(&mut self, v: u32) {
        self.probes = v;
    }

    // .google.protobuf.Duration time = 2;


    pub fn get_time(&self) -> &::protobuf::well_known_types::Duration {
        self.time.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Duration as ::protobuf::Message>::default_instance())
    }
    pub fn clear_time(&mut self) {
        self.time.clear();
    }

    pub fn has_time(&self) -> bool {
        self.time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time(&mut self, v: ::protobuf::well_known_types::Duration) {
        self.time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_time(&mut self) -> &mut ::protobuf::well_known_types::Duration {
        if self.time.is_none() {
            self.time.set_default();
        }
        self.time.as_mut().unwrap()
    }

    // Take field
    pub fn take_time(&mut self) -> ::protobuf::well_known_types::Duration {
        self.time.take().unwrap_or_else(|| ::protobuf::well_known_types::Duration::new())
    }

    // .google.protobuf.Duration interval = 3;


    pub fn get_interval(&self) -> &::protobuf::well_known_types::Duration {
        self.interval.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Duration as ::protobuf::Message>::default_instance())
    }
    pub fn clear_interval(&mut self) {
        self.interval.clear();
    }

    pub fn has_interval(&self) -> bool {
        self.interval.is_some()
    }

    // Param is passed by value, moved
    pub fn set_interval(&mut self, v: ::protobuf::well_known_types::Duration) {
        self.interval = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_interval(&mut self) -> &mut ::protobuf::well_known_types::Duration {
        if self.interval.is_none() {
            self.interval.set_default();
        }
        self.interval.as_mut().unwrap()
    }

    // Take field
    pub fn take_interval(&mut self) -> ::protobuf::well_known_types::Duration {
        self.interval.take().unwrap_or_else(|| ::protobuf::well_known_types::Duration::new())
    }
}

impl ::protobuf::Message for ConnectionPoolSettings_TCPSettings_TcpKeepalive {
    fn is_initialized(&self) -> bool {
        for v in &self.time {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.interval {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.probes = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.time)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.interval)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.probes != 0 {
            my_size += ::protobuf::rt::value_size(1, self.probes, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.interval.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.probes != 0 {
            os.write_uint32(1, self.probes)?;
        }
        if let Some(ref v) = self.time.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.interval.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ConnectionPoolSettings_TCPSettings_TcpKeepalive {
        ConnectionPoolSettings_TCPSettings_TcpKeepalive::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "probes",
                |m: &ConnectionPoolSettings_TCPSettings_TcpKeepalive| { &m.probes },
                |m: &mut ConnectionPoolSettings_TCPSettings_TcpKeepalive| { &mut m.probes },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Duration>>(
                "time",
                |m: &ConnectionPoolSettings_TCPSettings_TcpKeepalive| { &m.time },
                |m: &mut ConnectionPoolSettings_TCPSettings_TcpKeepalive| { &mut m.time },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Duration>>(
                "interval",
                |m: &ConnectionPoolSettings_TCPSettings_TcpKeepalive| { &m.interval },
                |m: &mut ConnectionPoolSettings_TCPSettings_TcpKeepalive| { &mut m.interval },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ConnectionPoolSettings_TCPSettings_TcpKeepalive>(
                "ConnectionPoolSettings.TCPSettings.TcpKeepalive",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ConnectionPoolSettings_TCPSettings_TcpKeepalive {
        static instance: ::protobuf::rt::LazyV2<ConnectionPoolSettings_TCPSettings_TcpKeepalive> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ConnectionPoolSettings_TCPSettings_TcpKeepalive::new)
    }
}

impl ::protobuf::Clear for ConnectionPoolSettings_TCPSettings_TcpKeepalive {
    fn clear(&mut self) {
        self.probes = 0;
        self.time.clear();
        self.interval.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ConnectionPoolSettings_TCPSettings_TcpKeepalive {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConnectionPoolSettings_TCPSettings_TcpKeepalive {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ConnectionPoolSettings_HTTPSettings {
    // message fields
    pub http1_max_pending_requests: i32,
    pub http2_max_requests: i32,
    pub max_requests_per_connection: i32,
    pub max_retries: i32,
    pub idle_timeout: ::protobuf::SingularPtrField<::protobuf::well_known_types::Duration>,
    pub h2_upgrade_policy: ConnectionPoolSettings_HTTPSettings_H2UpgradePolicy,
    pub use_client_protocol: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ConnectionPoolSettings_HTTPSettings {
    fn default() -> &'a ConnectionPoolSettings_HTTPSettings {
        <ConnectionPoolSettings_HTTPSettings as ::protobuf::Message>::default_instance()
    }
}

impl ConnectionPoolSettings_HTTPSettings {
    pub fn new() -> ConnectionPoolSettings_HTTPSettings {
        ::std::default::Default::default()
    }

    // int32 http1_max_pending_requests = 1;


    pub fn get_http1_max_pending_requests(&self) -> i32 {
        self.http1_max_pending_requests
    }
    pub fn clear_http1_max_pending_requests(&mut self) {
        self.http1_max_pending_requests = 0;
    }

    // Param is passed by value, moved
    pub fn set_http1_max_pending_requests(&mut self, v: i32) {
        self.http1_max_pending_requests = v;
    }

    // int32 http2_max_requests = 2;


    pub fn get_http2_max_requests(&self) -> i32 {
        self.http2_max_requests
    }
    pub fn clear_http2_max_requests(&mut self) {
        self.http2_max_requests = 0;
    }

    // Param is passed by value, moved
    pub fn set_http2_max_requests(&mut self, v: i32) {
        self.http2_max_requests = v;
    }

    // int32 max_requests_per_connection = 3;


    pub fn get_max_requests_per_connection(&self) -> i32 {
        self.max_requests_per_connection
    }
    pub fn clear_max_requests_per_connection(&mut self) {
        self.max_requests_per_connection = 0;
    }

    // Param is passed by value, moved
    pub fn set_max_requests_per_connection(&mut self, v: i32) {
        self.max_requests_per_connection = v;
    }

    // int32 max_retries = 4;


    pub fn get_max_retries(&self) -> i32 {
        self.max_retries
    }
    pub fn clear_max_retries(&mut self) {
        self.max_retries = 0;
    }

    // Param is passed by value, moved
    pub fn set_max_retries(&mut self, v: i32) {
        self.max_retries = v;
    }

    // .google.protobuf.Duration idle_timeout = 5;


    pub fn get_idle_timeout(&self) -> &::protobuf::well_known_types::Duration {
        self.idle_timeout.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Duration as ::protobuf::Message>::default_instance())
    }
    pub fn clear_idle_timeout(&mut self) {
        self.idle_timeout.clear();
    }

    pub fn has_idle_timeout(&self) -> bool {
        self.idle_timeout.is_some()
    }

    // Param is passed by value, moved
    pub fn set_idle_timeout(&mut self, v: ::protobuf::well_known_types::Duration) {
        self.idle_timeout = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_idle_timeout(&mut self) -> &mut ::protobuf::well_known_types::Duration {
        if self.idle_timeout.is_none() {
            self.idle_timeout.set_default();
        }
        self.idle_timeout.as_mut().unwrap()
    }

    // Take field
    pub fn take_idle_timeout(&mut self) -> ::protobuf::well_known_types::Duration {
        self.idle_timeout.take().unwrap_or_else(|| ::protobuf::well_known_types::Duration::new())
    }

    // .istio.networking.v1beta1.ConnectionPoolSettings.HTTPSettings.H2UpgradePolicy h2_upgrade_policy = 6;


    pub fn get_h2_upgrade_policy(&self) -> ConnectionPoolSettings_HTTPSettings_H2UpgradePolicy {
        self.h2_upgrade_policy
    }
    pub fn clear_h2_upgrade_policy(&mut self) {
        self.h2_upgrade_policy = ConnectionPoolSettings_HTTPSettings_H2UpgradePolicy::DEFAULT;
    }

    // Param is passed by value, moved
    pub fn set_h2_upgrade_policy(&mut self, v: ConnectionPoolSettings_HTTPSettings_H2UpgradePolicy) {
        self.h2_upgrade_policy = v;
    }

    // bool use_client_protocol = 7;


    pub fn get_use_client_protocol(&self) -> bool {
        self.use_client_protocol
    }
    pub fn clear_use_client_protocol(&mut self) {
        self.use_client_protocol = false;
    }

    // Param is passed by value, moved
    pub fn set_use_client_protocol(&mut self, v: bool) {
        self.use_client_protocol = v;
    }
}

impl ::protobuf::Message for ConnectionPoolSettings_HTTPSettings {
    fn is_initialized(&self) -> bool {
        for v in &self.idle_timeout {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.http1_max_pending_requests = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.http2_max_requests = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.max_requests_per_connection = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.max_retries = tmp;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.idle_timeout)?;
                },
                6 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.h2_upgrade_policy, 6, &mut self.unknown_fields)?
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.use_client_protocol = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.http1_max_pending_requests != 0 {
            my_size += ::protobuf::rt::value_size(1, self.http1_max_pending_requests, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.http2_max_requests != 0 {
            my_size += ::protobuf::rt::value_size(2, self.http2_max_requests, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.max_requests_per_connection != 0 {
            my_size += ::protobuf::rt::value_size(3, self.max_requests_per_connection, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.max_retries != 0 {
            my_size += ::protobuf::rt::value_size(4, self.max_retries, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.idle_timeout.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.h2_upgrade_policy != ConnectionPoolSettings_HTTPSettings_H2UpgradePolicy::DEFAULT {
            my_size += ::protobuf::rt::enum_size(6, self.h2_upgrade_policy);
        }
        if self.use_client_protocol != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.http1_max_pending_requests != 0 {
            os.write_int32(1, self.http1_max_pending_requests)?;
        }
        if self.http2_max_requests != 0 {
            os.write_int32(2, self.http2_max_requests)?;
        }
        if self.max_requests_per_connection != 0 {
            os.write_int32(3, self.max_requests_per_connection)?;
        }
        if self.max_retries != 0 {
            os.write_int32(4, self.max_retries)?;
        }
        if let Some(ref v) = self.idle_timeout.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.h2_upgrade_policy != ConnectionPoolSettings_HTTPSettings_H2UpgradePolicy::DEFAULT {
            os.write_enum(6, ::protobuf::ProtobufEnum::value(&self.h2_upgrade_policy))?;
        }
        if self.use_client_protocol != false {
            os.write_bool(7, self.use_client_protocol)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ConnectionPoolSettings_HTTPSettings {
        ConnectionPoolSettings_HTTPSettings::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "http1_max_pending_requests",
                |m: &ConnectionPoolSettings_HTTPSettings| { &m.http1_max_pending_requests },
                |m: &mut ConnectionPoolSettings_HTTPSettings| { &mut m.http1_max_pending_requests },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "http2_max_requests",
                |m: &ConnectionPoolSettings_HTTPSettings| { &m.http2_max_requests },
                |m: &mut ConnectionPoolSettings_HTTPSettings| { &mut m.http2_max_requests },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "max_requests_per_connection",
                |m: &ConnectionPoolSettings_HTTPSettings| { &m.max_requests_per_connection },
                |m: &mut ConnectionPoolSettings_HTTPSettings| { &mut m.max_requests_per_connection },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "max_retries",
                |m: &ConnectionPoolSettings_HTTPSettings| { &m.max_retries },
                |m: &mut ConnectionPoolSettings_HTTPSettings| { &mut m.max_retries },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Duration>>(
                "idle_timeout",
                |m: &ConnectionPoolSettings_HTTPSettings| { &m.idle_timeout },
                |m: &mut ConnectionPoolSettings_HTTPSettings| { &mut m.idle_timeout },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ConnectionPoolSettings_HTTPSettings_H2UpgradePolicy>>(
                "h2_upgrade_policy",
                |m: &ConnectionPoolSettings_HTTPSettings| { &m.h2_upgrade_policy },
                |m: &mut ConnectionPoolSettings_HTTPSettings| { &mut m.h2_upgrade_policy },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "use_client_protocol",
                |m: &ConnectionPoolSettings_HTTPSettings| { &m.use_client_protocol },
                |m: &mut ConnectionPoolSettings_HTTPSettings| { &mut m.use_client_protocol },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ConnectionPoolSettings_HTTPSettings>(
                "ConnectionPoolSettings.HTTPSettings",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ConnectionPoolSettings_HTTPSettings {
        static instance: ::protobuf::rt::LazyV2<ConnectionPoolSettings_HTTPSettings> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ConnectionPoolSettings_HTTPSettings::new)
    }
}

impl ::protobuf::Clear for ConnectionPoolSettings_HTTPSettings {
    fn clear(&mut self) {
        self.http1_max_pending_requests = 0;
        self.http2_max_requests = 0;
        self.max_requests_per_connection = 0;
        self.max_retries = 0;
        self.idle_timeout.clear();
        self.h2_upgrade_policy = ConnectionPoolSettings_HTTPSettings_H2UpgradePolicy::DEFAULT;
        self.use_client_protocol = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ConnectionPoolSettings_HTTPSettings {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConnectionPoolSettings_HTTPSettings {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ConnectionPoolSettings_HTTPSettings_H2UpgradePolicy {
    DEFAULT = 0,
    DO_NOT_UPGRADE = 1,
    UPGRADE = 2,
}

impl ::protobuf::ProtobufEnum for ConnectionPoolSettings_HTTPSettings_H2UpgradePolicy {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ConnectionPoolSettings_HTTPSettings_H2UpgradePolicy> {
        match value {
            0 => ::std::option::Option::Some(ConnectionPoolSettings_HTTPSettings_H2UpgradePolicy::DEFAULT),
            1 => ::std::option::Option::Some(ConnectionPoolSettings_HTTPSettings_H2UpgradePolicy::DO_NOT_UPGRADE),
            2 => ::std::option::Option::Some(ConnectionPoolSettings_HTTPSettings_H2UpgradePolicy::UPGRADE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ConnectionPoolSettings_HTTPSettings_H2UpgradePolicy] = &[
            ConnectionPoolSettings_HTTPSettings_H2UpgradePolicy::DEFAULT,
            ConnectionPoolSettings_HTTPSettings_H2UpgradePolicy::DO_NOT_UPGRADE,
            ConnectionPoolSettings_HTTPSettings_H2UpgradePolicy::UPGRADE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<ConnectionPoolSettings_HTTPSettings_H2UpgradePolicy>("ConnectionPoolSettings.HTTPSettings.H2UpgradePolicy", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for ConnectionPoolSettings_HTTPSettings_H2UpgradePolicy {
}

impl ::std::default::Default for ConnectionPoolSettings_HTTPSettings_H2UpgradePolicy {
    fn default() -> Self {
        ConnectionPoolSettings_HTTPSettings_H2UpgradePolicy::DEFAULT
    }
}

impl ::protobuf::reflect::ProtobufValue for ConnectionPoolSettings_HTTPSettings_H2UpgradePolicy {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OutlierDetection {
    // message fields
    pub consecutive_errors: i32,
    pub split_external_local_origin_errors: bool,
    pub consecutive_local_origin_failures: ::protobuf::SingularPtrField<::protobuf::well_known_types::UInt32Value>,
    pub consecutive_gateway_errors: ::protobuf::SingularPtrField<::protobuf::well_known_types::UInt32Value>,
    pub consecutive_5xx_errors: ::protobuf::SingularPtrField<::protobuf::well_known_types::UInt32Value>,
    pub interval: ::protobuf::SingularPtrField<::protobuf::well_known_types::Duration>,
    pub base_ejection_time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Duration>,
    pub max_ejection_percent: i32,
    pub min_health_percent: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OutlierDetection {
    fn default() -> &'a OutlierDetection {
        <OutlierDetection as ::protobuf::Message>::default_instance()
    }
}

impl OutlierDetection {
    pub fn new() -> OutlierDetection {
        ::std::default::Default::default()
    }

    // int32 consecutive_errors = 1;


    pub fn get_consecutive_errors(&self) -> i32 {
        self.consecutive_errors
    }
    pub fn clear_consecutive_errors(&mut self) {
        self.consecutive_errors = 0;
    }

    // Param is passed by value, moved
    pub fn set_consecutive_errors(&mut self, v: i32) {
        self.consecutive_errors = v;
    }

    // bool split_external_local_origin_errors = 8;


    pub fn get_split_external_local_origin_errors(&self) -> bool {
        self.split_external_local_origin_errors
    }
    pub fn clear_split_external_local_origin_errors(&mut self) {
        self.split_external_local_origin_errors = false;
    }

    // Param is passed by value, moved
    pub fn set_split_external_local_origin_errors(&mut self, v: bool) {
        self.split_external_local_origin_errors = v;
    }

    // .google.protobuf.UInt32Value consecutive_local_origin_failures = 9;


    pub fn get_consecutive_local_origin_failures(&self) -> &::protobuf::well_known_types::UInt32Value {
        self.consecutive_local_origin_failures.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::UInt32Value as ::protobuf::Message>::default_instance())
    }
    pub fn clear_consecutive_local_origin_failures(&mut self) {
        self.consecutive_local_origin_failures.clear();
    }

    pub fn has_consecutive_local_origin_failures(&self) -> bool {
        self.consecutive_local_origin_failures.is_some()
    }

    // Param is passed by value, moved
    pub fn set_consecutive_local_origin_failures(&mut self, v: ::protobuf::well_known_types::UInt32Value) {
        self.consecutive_local_origin_failures = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_consecutive_local_origin_failures(&mut self) -> &mut ::protobuf::well_known_types::UInt32Value {
        if self.consecutive_local_origin_failures.is_none() {
            self.consecutive_local_origin_failures.set_default();
        }
        self.consecutive_local_origin_failures.as_mut().unwrap()
    }

    // Take field
    pub fn take_consecutive_local_origin_failures(&mut self) -> ::protobuf::well_known_types::UInt32Value {
        self.consecutive_local_origin_failures.take().unwrap_or_else(|| ::protobuf::well_known_types::UInt32Value::new())
    }

    // .google.protobuf.UInt32Value consecutive_gateway_errors = 6;


    pub fn get_consecutive_gateway_errors(&self) -> &::protobuf::well_known_types::UInt32Value {
        self.consecutive_gateway_errors.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::UInt32Value as ::protobuf::Message>::default_instance())
    }
    pub fn clear_consecutive_gateway_errors(&mut self) {
        self.consecutive_gateway_errors.clear();
    }

    pub fn has_consecutive_gateway_errors(&self) -> bool {
        self.consecutive_gateway_errors.is_some()
    }

    // Param is passed by value, moved
    pub fn set_consecutive_gateway_errors(&mut self, v: ::protobuf::well_known_types::UInt32Value) {
        self.consecutive_gateway_errors = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_consecutive_gateway_errors(&mut self) -> &mut ::protobuf::well_known_types::UInt32Value {
        if self.consecutive_gateway_errors.is_none() {
            self.consecutive_gateway_errors.set_default();
        }
        self.consecutive_gateway_errors.as_mut().unwrap()
    }

    // Take field
    pub fn take_consecutive_gateway_errors(&mut self) -> ::protobuf::well_known_types::UInt32Value {
        self.consecutive_gateway_errors.take().unwrap_or_else(|| ::protobuf::well_known_types::UInt32Value::new())
    }

    // .google.protobuf.UInt32Value consecutive_5xx_errors = 7;


    pub fn get_consecutive_5xx_errors(&self) -> &::protobuf::well_known_types::UInt32Value {
        self.consecutive_5xx_errors.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::UInt32Value as ::protobuf::Message>::default_instance())
    }
    pub fn clear_consecutive_5xx_errors(&mut self) {
        self.consecutive_5xx_errors.clear();
    }

    pub fn has_consecutive_5xx_errors(&self) -> bool {
        self.consecutive_5xx_errors.is_some()
    }

    // Param is passed by value, moved
    pub fn set_consecutive_5xx_errors(&mut self, v: ::protobuf::well_known_types::UInt32Value) {
        self.consecutive_5xx_errors = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_consecutive_5xx_errors(&mut self) -> &mut ::protobuf::well_known_types::UInt32Value {
        if self.consecutive_5xx_errors.is_none() {
            self.consecutive_5xx_errors.set_default();
        }
        self.consecutive_5xx_errors.as_mut().unwrap()
    }

    // Take field
    pub fn take_consecutive_5xx_errors(&mut self) -> ::protobuf::well_known_types::UInt32Value {
        self.consecutive_5xx_errors.take().unwrap_or_else(|| ::protobuf::well_known_types::UInt32Value::new())
    }

    // .google.protobuf.Duration interval = 2;


    pub fn get_interval(&self) -> &::protobuf::well_known_types::Duration {
        self.interval.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Duration as ::protobuf::Message>::default_instance())
    }
    pub fn clear_interval(&mut self) {
        self.interval.clear();
    }

    pub fn has_interval(&self) -> bool {
        self.interval.is_some()
    }

    // Param is passed by value, moved
    pub fn set_interval(&mut self, v: ::protobuf::well_known_types::Duration) {
        self.interval = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_interval(&mut self) -> &mut ::protobuf::well_known_types::Duration {
        if self.interval.is_none() {
            self.interval.set_default();
        }
        self.interval.as_mut().unwrap()
    }

    // Take field
    pub fn take_interval(&mut self) -> ::protobuf::well_known_types::Duration {
        self.interval.take().unwrap_or_else(|| ::protobuf::well_known_types::Duration::new())
    }

    // .google.protobuf.Duration base_ejection_time = 3;


    pub fn get_base_ejection_time(&self) -> &::protobuf::well_known_types::Duration {
        self.base_ejection_time.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Duration as ::protobuf::Message>::default_instance())
    }
    pub fn clear_base_ejection_time(&mut self) {
        self.base_ejection_time.clear();
    }

    pub fn has_base_ejection_time(&self) -> bool {
        self.base_ejection_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_base_ejection_time(&mut self, v: ::protobuf::well_known_types::Duration) {
        self.base_ejection_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_base_ejection_time(&mut self) -> &mut ::protobuf::well_known_types::Duration {
        if self.base_ejection_time.is_none() {
            self.base_ejection_time.set_default();
        }
        self.base_ejection_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_base_ejection_time(&mut self) -> ::protobuf::well_known_types::Duration {
        self.base_ejection_time.take().unwrap_or_else(|| ::protobuf::well_known_types::Duration::new())
    }

    // int32 max_ejection_percent = 4;


    pub fn get_max_ejection_percent(&self) -> i32 {
        self.max_ejection_percent
    }
    pub fn clear_max_ejection_percent(&mut self) {
        self.max_ejection_percent = 0;
    }

    // Param is passed by value, moved
    pub fn set_max_ejection_percent(&mut self, v: i32) {
        self.max_ejection_percent = v;
    }

    // int32 min_health_percent = 5;


    pub fn get_min_health_percent(&self) -> i32 {
        self.min_health_percent
    }
    pub fn clear_min_health_percent(&mut self) {
        self.min_health_percent = 0;
    }

    // Param is passed by value, moved
    pub fn set_min_health_percent(&mut self, v: i32) {
        self.min_health_percent = v;
    }
}

impl ::protobuf::Message for OutlierDetection {
    fn is_initialized(&self) -> bool {
        for v in &self.consecutive_local_origin_failures {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.consecutive_gateway_errors {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.consecutive_5xx_errors {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.interval {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.base_ejection_time {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.consecutive_errors = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.split_external_local_origin_errors = tmp;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.consecutive_local_origin_failures)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.consecutive_gateway_errors)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.consecutive_5xx_errors)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.interval)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.base_ejection_time)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.max_ejection_percent = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.min_health_percent = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.consecutive_errors != 0 {
            my_size += ::protobuf::rt::value_size(1, self.consecutive_errors, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.split_external_local_origin_errors != false {
            my_size += 2;
        }
        if let Some(ref v) = self.consecutive_local_origin_failures.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.consecutive_gateway_errors.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.consecutive_5xx_errors.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.interval.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.base_ejection_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.max_ejection_percent != 0 {
            my_size += ::protobuf::rt::value_size(4, self.max_ejection_percent, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.min_health_percent != 0 {
            my_size += ::protobuf::rt::value_size(5, self.min_health_percent, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.consecutive_errors != 0 {
            os.write_int32(1, self.consecutive_errors)?;
        }
        if self.split_external_local_origin_errors != false {
            os.write_bool(8, self.split_external_local_origin_errors)?;
        }
        if let Some(ref v) = self.consecutive_local_origin_failures.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.consecutive_gateway_errors.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.consecutive_5xx_errors.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.interval.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.base_ejection_time.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.max_ejection_percent != 0 {
            os.write_int32(4, self.max_ejection_percent)?;
        }
        if self.min_health_percent != 0 {
            os.write_int32(5, self.min_health_percent)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OutlierDetection {
        OutlierDetection::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "consecutive_errors",
                |m: &OutlierDetection| { &m.consecutive_errors },
                |m: &mut OutlierDetection| { &mut m.consecutive_errors },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "split_external_local_origin_errors",
                |m: &OutlierDetection| { &m.split_external_local_origin_errors },
                |m: &mut OutlierDetection| { &mut m.split_external_local_origin_errors },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::UInt32Value>>(
                "consecutive_local_origin_failures",
                |m: &OutlierDetection| { &m.consecutive_local_origin_failures },
                |m: &mut OutlierDetection| { &mut m.consecutive_local_origin_failures },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::UInt32Value>>(
                "consecutive_gateway_errors",
                |m: &OutlierDetection| { &m.consecutive_gateway_errors },
                |m: &mut OutlierDetection| { &mut m.consecutive_gateway_errors },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::UInt32Value>>(
                "consecutive_5xx_errors",
                |m: &OutlierDetection| { &m.consecutive_5xx_errors },
                |m: &mut OutlierDetection| { &mut m.consecutive_5xx_errors },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Duration>>(
                "interval",
                |m: &OutlierDetection| { &m.interval },
                |m: &mut OutlierDetection| { &mut m.interval },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Duration>>(
                "base_ejection_time",
                |m: &OutlierDetection| { &m.base_ejection_time },
                |m: &mut OutlierDetection| { &mut m.base_ejection_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "max_ejection_percent",
                |m: &OutlierDetection| { &m.max_ejection_percent },
                |m: &mut OutlierDetection| { &mut m.max_ejection_percent },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "min_health_percent",
                |m: &OutlierDetection| { &m.min_health_percent },
                |m: &mut OutlierDetection| { &mut m.min_health_percent },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<OutlierDetection>(
                "OutlierDetection",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static OutlierDetection {
        static instance: ::protobuf::rt::LazyV2<OutlierDetection> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OutlierDetection::new)
    }
}

impl ::protobuf::Clear for OutlierDetection {
    fn clear(&mut self) {
        self.consecutive_errors = 0;
        self.split_external_local_origin_errors = false;
        self.consecutive_local_origin_failures.clear();
        self.consecutive_gateway_errors.clear();
        self.consecutive_5xx_errors.clear();
        self.interval.clear();
        self.base_ejection_time.clear();
        self.max_ejection_percent = 0;
        self.min_health_percent = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OutlierDetection {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OutlierDetection {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ClientTLSSettings {
    // message fields
    pub mode: ClientTLSSettings_TLSmode,
    pub client_certificate: ::std::string::String,
    pub private_key: ::std::string::String,
    pub ca_certificates: ::std::string::String,
    pub credential_name: ::std::string::String,
    pub subject_alt_names: ::protobuf::RepeatedField<::std::string::String>,
    pub sni: ::std::string::String,
    pub insecure_skip_verify: ::protobuf::SingularPtrField<::protobuf::well_known_types::BoolValue>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ClientTLSSettings {
    fn default() -> &'a ClientTLSSettings {
        <ClientTLSSettings as ::protobuf::Message>::default_instance()
    }
}

impl ClientTLSSettings {
    pub fn new() -> ClientTLSSettings {
        ::std::default::Default::default()
    }

    // .istio.networking.v1beta1.ClientTLSSettings.TLSmode mode = 1;


    pub fn get_mode(&self) -> ClientTLSSettings_TLSmode {
        self.mode
    }
    pub fn clear_mode(&mut self) {
        self.mode = ClientTLSSettings_TLSmode::DISABLE;
    }

    // Param is passed by value, moved
    pub fn set_mode(&mut self, v: ClientTLSSettings_TLSmode) {
        self.mode = v;
    }

    // string client_certificate = 2;


    pub fn get_client_certificate(&self) -> &str {
        &self.client_certificate
    }
    pub fn clear_client_certificate(&mut self) {
        self.client_certificate.clear();
    }

    // Param is passed by value, moved
    pub fn set_client_certificate(&mut self, v: ::std::string::String) {
        self.client_certificate = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_client_certificate(&mut self) -> &mut ::std::string::String {
        &mut self.client_certificate
    }

    // Take field
    pub fn take_client_certificate(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.client_certificate, ::std::string::String::new())
    }

    // string private_key = 3;


    pub fn get_private_key(&self) -> &str {
        &self.private_key
    }
    pub fn clear_private_key(&mut self) {
        self.private_key.clear();
    }

    // Param is passed by value, moved
    pub fn set_private_key(&mut self, v: ::std::string::String) {
        self.private_key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_private_key(&mut self) -> &mut ::std::string::String {
        &mut self.private_key
    }

    // Take field
    pub fn take_private_key(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.private_key, ::std::string::String::new())
    }

    // string ca_certificates = 4;


    pub fn get_ca_certificates(&self) -> &str {
        &self.ca_certificates
    }
    pub fn clear_ca_certificates(&mut self) {
        self.ca_certificates.clear();
    }

    // Param is passed by value, moved
    pub fn set_ca_certificates(&mut self, v: ::std::string::String) {
        self.ca_certificates = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ca_certificates(&mut self) -> &mut ::std::string::String {
        &mut self.ca_certificates
    }

    // Take field
    pub fn take_ca_certificates(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.ca_certificates, ::std::string::String::new())
    }

    // string credential_name = 7;


    pub fn get_credential_name(&self) -> &str {
        &self.credential_name
    }
    pub fn clear_credential_name(&mut self) {
        self.credential_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_credential_name(&mut self, v: ::std::string::String) {
        self.credential_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_credential_name(&mut self) -> &mut ::std::string::String {
        &mut self.credential_name
    }

    // Take field
    pub fn take_credential_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.credential_name, ::std::string::String::new())
    }

    // repeated string subject_alt_names = 5;


    pub fn get_subject_alt_names(&self) -> &[::std::string::String] {
        &self.subject_alt_names
    }
    pub fn clear_subject_alt_names(&mut self) {
        self.subject_alt_names.clear();
    }

    // Param is passed by value, moved
    pub fn set_subject_alt_names(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.subject_alt_names = v;
    }

    // Mutable pointer to the field.
    pub fn mut_subject_alt_names(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.subject_alt_names
    }

    // Take field
    pub fn take_subject_alt_names(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.subject_alt_names, ::protobuf::RepeatedField::new())
    }

    // string sni = 6;


    pub fn get_sni(&self) -> &str {
        &self.sni
    }
    pub fn clear_sni(&mut self) {
        self.sni.clear();
    }

    // Param is passed by value, moved
    pub fn set_sni(&mut self, v: ::std::string::String) {
        self.sni = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sni(&mut self) -> &mut ::std::string::String {
        &mut self.sni
    }

    // Take field
    pub fn take_sni(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.sni, ::std::string::String::new())
    }

    // .google.protobuf.BoolValue insecure_skip_verify = 8;


    pub fn get_insecure_skip_verify(&self) -> &::protobuf::well_known_types::BoolValue {
        self.insecure_skip_verify.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::BoolValue as ::protobuf::Message>::default_instance())
    }
    pub fn clear_insecure_skip_verify(&mut self) {
        self.insecure_skip_verify.clear();
    }

    pub fn has_insecure_skip_verify(&self) -> bool {
        self.insecure_skip_verify.is_some()
    }

    // Param is passed by value, moved
    pub fn set_insecure_skip_verify(&mut self, v: ::protobuf::well_known_types::BoolValue) {
        self.insecure_skip_verify = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_insecure_skip_verify(&mut self) -> &mut ::protobuf::well_known_types::BoolValue {
        if self.insecure_skip_verify.is_none() {
            self.insecure_skip_verify.set_default();
        }
        self.insecure_skip_verify.as_mut().unwrap()
    }

    // Take field
    pub fn take_insecure_skip_verify(&mut self) -> ::protobuf::well_known_types::BoolValue {
        self.insecure_skip_verify.take().unwrap_or_else(|| ::protobuf::well_known_types::BoolValue::new())
    }
}

impl ::protobuf::Message for ClientTLSSettings {
    fn is_initialized(&self) -> bool {
        for v in &self.insecure_skip_verify {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.mode, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.client_certificate)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.private_key)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.ca_certificates)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.credential_name)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.subject_alt_names)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.sni)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.insecure_skip_verify)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.mode != ClientTLSSettings_TLSmode::DISABLE {
            my_size += ::protobuf::rt::enum_size(1, self.mode);
        }
        if !self.client_certificate.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.client_certificate);
        }
        if !self.private_key.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.private_key);
        }
        if !self.ca_certificates.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.ca_certificates);
        }
        if !self.credential_name.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.credential_name);
        }
        for value in &self.subject_alt_names {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        if !self.sni.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.sni);
        }
        if let Some(ref v) = self.insecure_skip_verify.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.mode != ClientTLSSettings_TLSmode::DISABLE {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.mode))?;
        }
        if !self.client_certificate.is_empty() {
            os.write_string(2, &self.client_certificate)?;
        }
        if !self.private_key.is_empty() {
            os.write_string(3, &self.private_key)?;
        }
        if !self.ca_certificates.is_empty() {
            os.write_string(4, &self.ca_certificates)?;
        }
        if !self.credential_name.is_empty() {
            os.write_string(7, &self.credential_name)?;
        }
        for v in &self.subject_alt_names {
            os.write_string(5, &v)?;
        };
        if !self.sni.is_empty() {
            os.write_string(6, &self.sni)?;
        }
        if let Some(ref v) = self.insecure_skip_verify.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ClientTLSSettings {
        ClientTLSSettings::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ClientTLSSettings_TLSmode>>(
                "mode",
                |m: &ClientTLSSettings| { &m.mode },
                |m: &mut ClientTLSSettings| { &mut m.mode },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "client_certificate",
                |m: &ClientTLSSettings| { &m.client_certificate },
                |m: &mut ClientTLSSettings| { &mut m.client_certificate },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "private_key",
                |m: &ClientTLSSettings| { &m.private_key },
                |m: &mut ClientTLSSettings| { &mut m.private_key },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "ca_certificates",
                |m: &ClientTLSSettings| { &m.ca_certificates },
                |m: &mut ClientTLSSettings| { &mut m.ca_certificates },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "credential_name",
                |m: &ClientTLSSettings| { &m.credential_name },
                |m: &mut ClientTLSSettings| { &mut m.credential_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "subject_alt_names",
                |m: &ClientTLSSettings| { &m.subject_alt_names },
                |m: &mut ClientTLSSettings| { &mut m.subject_alt_names },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "sni",
                |m: &ClientTLSSettings| { &m.sni },
                |m: &mut ClientTLSSettings| { &mut m.sni },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::BoolValue>>(
                "insecure_skip_verify",
                |m: &ClientTLSSettings| { &m.insecure_skip_verify },
                |m: &mut ClientTLSSettings| { &mut m.insecure_skip_verify },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ClientTLSSettings>(
                "ClientTLSSettings",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ClientTLSSettings {
        static instance: ::protobuf::rt::LazyV2<ClientTLSSettings> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ClientTLSSettings::new)
    }
}

impl ::protobuf::Clear for ClientTLSSettings {
    fn clear(&mut self) {
        self.mode = ClientTLSSettings_TLSmode::DISABLE;
        self.client_certificate.clear();
        self.private_key.clear();
        self.ca_certificates.clear();
        self.credential_name.clear();
        self.subject_alt_names.clear();
        self.sni.clear();
        self.insecure_skip_verify.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ClientTLSSettings {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ClientTLSSettings {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ClientTLSSettings_TLSmode {
    DISABLE = 0,
    SIMPLE = 1,
    MUTUAL = 2,
    ISTIO_MUTUAL = 3,
}

impl ::protobuf::ProtobufEnum for ClientTLSSettings_TLSmode {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ClientTLSSettings_TLSmode> {
        match value {
            0 => ::std::option::Option::Some(ClientTLSSettings_TLSmode::DISABLE),
            1 => ::std::option::Option::Some(ClientTLSSettings_TLSmode::SIMPLE),
            2 => ::std::option::Option::Some(ClientTLSSettings_TLSmode::MUTUAL),
            3 => ::std::option::Option::Some(ClientTLSSettings_TLSmode::ISTIO_MUTUAL),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ClientTLSSettings_TLSmode] = &[
            ClientTLSSettings_TLSmode::DISABLE,
            ClientTLSSettings_TLSmode::SIMPLE,
            ClientTLSSettings_TLSmode::MUTUAL,
            ClientTLSSettings_TLSmode::ISTIO_MUTUAL,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<ClientTLSSettings_TLSmode>("ClientTLSSettings.TLSmode", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for ClientTLSSettings_TLSmode {
}

impl ::std::default::Default for ClientTLSSettings_TLSmode {
    fn default() -> Self {
        ClientTLSSettings_TLSmode::DISABLE
    }
}

impl ::protobuf::reflect::ProtobufValue for ClientTLSSettings_TLSmode {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LocalityLoadBalancerSetting {
    // message fields
    pub distribute: ::protobuf::RepeatedField<LocalityLoadBalancerSetting_Distribute>,
    pub failover: ::protobuf::RepeatedField<LocalityLoadBalancerSetting_Failover>,
    pub failover_priority: ::protobuf::RepeatedField<::std::string::String>,
    pub enabled: ::protobuf::SingularPtrField<::protobuf::well_known_types::BoolValue>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LocalityLoadBalancerSetting {
    fn default() -> &'a LocalityLoadBalancerSetting {
        <LocalityLoadBalancerSetting as ::protobuf::Message>::default_instance()
    }
}

impl LocalityLoadBalancerSetting {
    pub fn new() -> LocalityLoadBalancerSetting {
        ::std::default::Default::default()
    }

    // repeated .istio.networking.v1beta1.LocalityLoadBalancerSetting.Distribute distribute = 1;


    pub fn get_distribute(&self) -> &[LocalityLoadBalancerSetting_Distribute] {
        &self.distribute
    }
    pub fn clear_distribute(&mut self) {
        self.distribute.clear();
    }

    // Param is passed by value, moved
    pub fn set_distribute(&mut self, v: ::protobuf::RepeatedField<LocalityLoadBalancerSetting_Distribute>) {
        self.distribute = v;
    }

    // Mutable pointer to the field.
    pub fn mut_distribute(&mut self) -> &mut ::protobuf::RepeatedField<LocalityLoadBalancerSetting_Distribute> {
        &mut self.distribute
    }

    // Take field
    pub fn take_distribute(&mut self) -> ::protobuf::RepeatedField<LocalityLoadBalancerSetting_Distribute> {
        ::std::mem::replace(&mut self.distribute, ::protobuf::RepeatedField::new())
    }

    // repeated .istio.networking.v1beta1.LocalityLoadBalancerSetting.Failover failover = 2;


    pub fn get_failover(&self) -> &[LocalityLoadBalancerSetting_Failover] {
        &self.failover
    }
    pub fn clear_failover(&mut self) {
        self.failover.clear();
    }

    // Param is passed by value, moved
    pub fn set_failover(&mut self, v: ::protobuf::RepeatedField<LocalityLoadBalancerSetting_Failover>) {
        self.failover = v;
    }

    // Mutable pointer to the field.
    pub fn mut_failover(&mut self) -> &mut ::protobuf::RepeatedField<LocalityLoadBalancerSetting_Failover> {
        &mut self.failover
    }

    // Take field
    pub fn take_failover(&mut self) -> ::protobuf::RepeatedField<LocalityLoadBalancerSetting_Failover> {
        ::std::mem::replace(&mut self.failover, ::protobuf::RepeatedField::new())
    }

    // repeated string failover_priority = 4;


    pub fn get_failover_priority(&self) -> &[::std::string::String] {
        &self.failover_priority
    }
    pub fn clear_failover_priority(&mut self) {
        self.failover_priority.clear();
    }

    // Param is passed by value, moved
    pub fn set_failover_priority(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.failover_priority = v;
    }

    // Mutable pointer to the field.
    pub fn mut_failover_priority(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.failover_priority
    }

    // Take field
    pub fn take_failover_priority(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.failover_priority, ::protobuf::RepeatedField::new())
    }

    // .google.protobuf.BoolValue enabled = 3;


    pub fn get_enabled(&self) -> &::protobuf::well_known_types::BoolValue {
        self.enabled.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::BoolValue as ::protobuf::Message>::default_instance())
    }
    pub fn clear_enabled(&mut self) {
        self.enabled.clear();
    }

    pub fn has_enabled(&self) -> bool {
        self.enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enabled(&mut self, v: ::protobuf::well_known_types::BoolValue) {
        self.enabled = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_enabled(&mut self) -> &mut ::protobuf::well_known_types::BoolValue {
        if self.enabled.is_none() {
            self.enabled.set_default();
        }
        self.enabled.as_mut().unwrap()
    }

    // Take field
    pub fn take_enabled(&mut self) -> ::protobuf::well_known_types::BoolValue {
        self.enabled.take().unwrap_or_else(|| ::protobuf::well_known_types::BoolValue::new())
    }
}

impl ::protobuf::Message for LocalityLoadBalancerSetting {
    fn is_initialized(&self) -> bool {
        for v in &self.distribute {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.failover {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.enabled {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.distribute)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.failover)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.failover_priority)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.enabled)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.distribute {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.failover {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.failover_priority {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        if let Some(ref v) = self.enabled.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.distribute {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.failover {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.failover_priority {
            os.write_string(4, &v)?;
        };
        if let Some(ref v) = self.enabled.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LocalityLoadBalancerSetting {
        LocalityLoadBalancerSetting::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LocalityLoadBalancerSetting_Distribute>>(
                "distribute",
                |m: &LocalityLoadBalancerSetting| { &m.distribute },
                |m: &mut LocalityLoadBalancerSetting| { &mut m.distribute },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LocalityLoadBalancerSetting_Failover>>(
                "failover",
                |m: &LocalityLoadBalancerSetting| { &m.failover },
                |m: &mut LocalityLoadBalancerSetting| { &mut m.failover },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "failover_priority",
                |m: &LocalityLoadBalancerSetting| { &m.failover_priority },
                |m: &mut LocalityLoadBalancerSetting| { &mut m.failover_priority },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::BoolValue>>(
                "enabled",
                |m: &LocalityLoadBalancerSetting| { &m.enabled },
                |m: &mut LocalityLoadBalancerSetting| { &mut m.enabled },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LocalityLoadBalancerSetting>(
                "LocalityLoadBalancerSetting",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LocalityLoadBalancerSetting {
        static instance: ::protobuf::rt::LazyV2<LocalityLoadBalancerSetting> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LocalityLoadBalancerSetting::new)
    }
}

impl ::protobuf::Clear for LocalityLoadBalancerSetting {
    fn clear(&mut self) {
        self.distribute.clear();
        self.failover.clear();
        self.failover_priority.clear();
        self.enabled.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LocalityLoadBalancerSetting {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LocalityLoadBalancerSetting {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LocalityLoadBalancerSetting_Distribute {
    // message fields
    pub from: ::std::string::String,
    pub to: ::std::collections::HashMap<::std::string::String, u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LocalityLoadBalancerSetting_Distribute {
    fn default() -> &'a LocalityLoadBalancerSetting_Distribute {
        <LocalityLoadBalancerSetting_Distribute as ::protobuf::Message>::default_instance()
    }
}

impl LocalityLoadBalancerSetting_Distribute {
    pub fn new() -> LocalityLoadBalancerSetting_Distribute {
        ::std::default::Default::default()
    }

    // string from = 1;


    pub fn get_from(&self) -> &str {
        &self.from
    }
    pub fn clear_from(&mut self) {
        self.from.clear();
    }

    // Param is passed by value, moved
    pub fn set_from(&mut self, v: ::std::string::String) {
        self.from = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_from(&mut self) -> &mut ::std::string::String {
        &mut self.from
    }

    // Take field
    pub fn take_from(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.from, ::std::string::String::new())
    }

    // repeated .istio.networking.v1beta1.LocalityLoadBalancerSetting.Distribute.ToEntry to = 2;


    pub fn get_to(&self) -> &::std::collections::HashMap<::std::string::String, u32> {
        &self.to
    }
    pub fn clear_to(&mut self) {
        self.to.clear();
    }

    // Param is passed by value, moved
    pub fn set_to(&mut self, v: ::std::collections::HashMap<::std::string::String, u32>) {
        self.to = v;
    }

    // Mutable pointer to the field.
    pub fn mut_to(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, u32> {
        &mut self.to
    }

    // Take field
    pub fn take_to(&mut self) -> ::std::collections::HashMap<::std::string::String, u32> {
        ::std::mem::replace(&mut self.to, ::std::collections::HashMap::new())
    }
}

impl ::protobuf::Message for LocalityLoadBalancerSetting_Distribute {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.from)?;
                },
                2 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeUint32>(wire_type, is, &mut self.to)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.from.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.from);
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeUint32>(2, &self.to);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.from.is_empty() {
            os.write_string(1, &self.from)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeUint32>(2, &self.to, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LocalityLoadBalancerSetting_Distribute {
        LocalityLoadBalancerSetting_Distribute::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "from",
                |m: &LocalityLoadBalancerSetting_Distribute| { &m.from },
                |m: &mut LocalityLoadBalancerSetting_Distribute| { &mut m.from },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeUint32>(
                "to",
                |m: &LocalityLoadBalancerSetting_Distribute| { &m.to },
                |m: &mut LocalityLoadBalancerSetting_Distribute| { &mut m.to },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LocalityLoadBalancerSetting_Distribute>(
                "LocalityLoadBalancerSetting.Distribute",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LocalityLoadBalancerSetting_Distribute {
        static instance: ::protobuf::rt::LazyV2<LocalityLoadBalancerSetting_Distribute> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LocalityLoadBalancerSetting_Distribute::new)
    }
}

impl ::protobuf::Clear for LocalityLoadBalancerSetting_Distribute {
    fn clear(&mut self) {
        self.from.clear();
        self.to.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LocalityLoadBalancerSetting_Distribute {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LocalityLoadBalancerSetting_Distribute {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LocalityLoadBalancerSetting_Failover {
    // message fields
    pub from: ::std::string::String,
    pub to: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LocalityLoadBalancerSetting_Failover {
    fn default() -> &'a LocalityLoadBalancerSetting_Failover {
        <LocalityLoadBalancerSetting_Failover as ::protobuf::Message>::default_instance()
    }
}

impl LocalityLoadBalancerSetting_Failover {
    pub fn new() -> LocalityLoadBalancerSetting_Failover {
        ::std::default::Default::default()
    }

    // string from = 1;


    pub fn get_from(&self) -> &str {
        &self.from
    }
    pub fn clear_from(&mut self) {
        self.from.clear();
    }

    // Param is passed by value, moved
    pub fn set_from(&mut self, v: ::std::string::String) {
        self.from = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_from(&mut self) -> &mut ::std::string::String {
        &mut self.from
    }

    // Take field
    pub fn take_from(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.from, ::std::string::String::new())
    }

    // string to = 2;


    pub fn get_to(&self) -> &str {
        &self.to
    }
    pub fn clear_to(&mut self) {
        self.to.clear();
    }

    // Param is passed by value, moved
    pub fn set_to(&mut self, v: ::std::string::String) {
        self.to = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_to(&mut self) -> &mut ::std::string::String {
        &mut self.to
    }

    // Take field
    pub fn take_to(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.to, ::std::string::String::new())
    }
}

impl ::protobuf::Message for LocalityLoadBalancerSetting_Failover {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.from)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.to)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.from.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.from);
        }
        if !self.to.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.to);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.from.is_empty() {
            os.write_string(1, &self.from)?;
        }
        if !self.to.is_empty() {
            os.write_string(2, &self.to)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LocalityLoadBalancerSetting_Failover {
        LocalityLoadBalancerSetting_Failover::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "from",
                |m: &LocalityLoadBalancerSetting_Failover| { &m.from },
                |m: &mut LocalityLoadBalancerSetting_Failover| { &mut m.from },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "to",
                |m: &LocalityLoadBalancerSetting_Failover| { &m.to },
                |m: &mut LocalityLoadBalancerSetting_Failover| { &mut m.to },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LocalityLoadBalancerSetting_Failover>(
                "LocalityLoadBalancerSetting.Failover",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LocalityLoadBalancerSetting_Failover {
        static instance: ::protobuf::rt::LazyV2<LocalityLoadBalancerSetting_Failover> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LocalityLoadBalancerSetting_Failover::new)
    }
}

impl ::protobuf::Clear for LocalityLoadBalancerSetting_Failover {
    fn clear(&mut self) {
        self.from.clear();
        self.to.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LocalityLoadBalancerSetting_Failover {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LocalityLoadBalancerSetting_Failover {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n)networking/v1beta1/destination_rule.proto\x12\x18istio.networking.v1b\
    eta1\x1a\x1fgoogle/api/field_behavior.proto\x1a\x1egoogle/protobuf/durat\
    ion.proto\x1a\x1egoogle/protobuf/wrappers.proto\x1a(networking/v1beta1/v\
    irtual_service.proto\x1a\x1btype/v1beta1/selector.proto\"\xa6\x02\n\x0fD\
    estinationRule\x12\x17\n\x04host\x18\x01\x20\x01(\tR\x04hostB\x03\xe0A\
    \x02\x12N\n\x0etraffic_policy\x18\x02\x20\x01(\x0b2'.istio.networking.v1\
    beta1.TrafficPolicyR\rtrafficPolicy\x12:\n\x07subsets\x18\x03\x20\x03(\
    \x0b2\x20.istio.networking.v1beta1.SubsetR\x07subsets\x12\x1b\n\texport_\
    to\x18\x04\x20\x03(\tR\x08exportTo\x12Q\n\x11workload_selector\x18\x05\
    \x20\x01(\x0b2$.istio.type.v1beta1.WorkloadSelectorR\x10workloadSelector\
    \"\xab\x08\n\rTrafficPolicy\x12S\n\rload_balancer\x18\x01\x20\x01(\x0b2.\
    .istio.networking.v1beta1.LoadBalancerSettingsR\x0cloadBalancer\x12Y\n\
    \x0fconnection_pool\x18\x02\x20\x01(\x0b20.istio.networking.v1beta1.Conn\
    ectionPoolSettingsR\x0econnectionPool\x12W\n\x11outlier_detection\x18\
    \x03\x20\x01(\x0b2*.istio.networking.v1beta1.OutlierDetectionR\x10outlie\
    rDetection\x12=\n\x03tls\x18\x04\x20\x01(\x0b2+.istio.networking.v1beta1\
    .ClientTLSSettingsR\x03tls\x12i\n\x13port_level_settings\x18\x05\x20\x03\
    (\x0b29.istio.networking.v1beta1.TrafficPolicy.PortTrafficPolicyR\x11por\
    tLevelSettings\x12N\n\x06tunnel\x18\x06\x20\x01(\x0b26.istio.networking.\
    v1beta1.TrafficPolicy.TunnelSettingsR\x06tunnel\x1a\x97\x03\n\x11PortTra\
    fficPolicy\x12:\n\x04port\x18\x01\x20\x01(\x0b2&.istio.networking.v1beta\
    1.PortSelectorR\x04port\x12S\n\rload_balancer\x18\x02\x20\x01(\x0b2..ist\
    io.networking.v1beta1.LoadBalancerSettingsR\x0cloadBalancer\x12Y\n\x0fco\
    nnection_pool\x18\x03\x20\x01(\x0b20.istio.networking.v1beta1.Connection\
    PoolSettingsR\x0econnectionPool\x12W\n\x11outlier_detection\x18\x04\x20\
    \x01(\x0b2*.istio.networking.v1beta1.OutlierDetectionR\x10outlierDetecti\
    on\x12=\n\x03tls\x18\x05\x20\x01(\x0b2+.istio.networking.v1beta1.ClientT\
    LSSettingsR\x03tls\x1a}\n\x0eTunnelSettings\x12\x1f\n\x08protocol\x18\
    \x01\x20\x01(\tR\x08protocolB\x03\xe0A\x02\x12$\n\x0btarget_host\x18\x02\
    \x20\x01(\tR\ntargetHostB\x03\xe0A\x02\x12$\n\x0btarget_port\x18\x03\x20\
    \x01(\rR\ntargetPortB\x03\xe0A\x02\"\xf2\x01\n\x06Subset\x12\x17\n\x04na\
    me\x18\x01\x20\x01(\tR\x04nameB\x03\xe0A\x02\x12D\n\x06labels\x18\x02\
    \x20\x03(\x0b2,.istio.networking.v1beta1.Subset.LabelsEntryR\x06labels\
    \x12N\n\x0etraffic_policy\x18\x03\x20\x01(\x0b2'.istio.networking.v1beta\
    1.TrafficPolicyR\rtrafficPolicy\x1a9\n\x0bLabelsEntry\x12\x10\n\x03key\
    \x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05va\
    lue:\x028\x01\"\xc0\x07\n\x14LoadBalancerSettings\x12Q\n\x06simple\x18\
    \x01\x20\x01(\x0e27.istio.networking.v1beta1.LoadBalancerSettings.Simple\
    LBH\0R\x06simple\x12j\n\x0fconsistent_hash\x18\x02\x20\x01(\x0b2?.istio.\
    networking.v1beta1.LoadBalancerSettings.ConsistentHashLBH\0R\x0econsiste\
    ntHash\x12e\n\x13locality_lb_setting\x18\x03\x20\x01(\x0b25.istio.networ\
    king.v1beta1.LocalityLoadBalancerSettingR\x11localityLbSetting\x12K\n\
    \x14warmup_duration_secs\x18\x04\x20\x01(\x0b2\x19.google.protobuf.Durat\
    ionR\x12warmupDurationSecs\x1a\xb5\x03\n\x10ConsistentHashLB\x12*\n\x10h\
    ttp_header_name\x18\x01\x20\x01(\tH\0R\x0ehttpHeaderName\x12m\n\x0bhttp_\
    cookie\x18\x02\x20\x01(\x0b2J.istio.networking.v1beta1.LoadBalancerSetti\
    ngs.ConsistentHashLB.HTTPCookieH\0R\nhttpCookie\x12$\n\ruse_source_ip\
    \x18\x03\x20\x01(\x08H\0R\x0buseSourceIp\x12;\n\x19http_query_parameter_\
    name\x18\x05\x20\x01(\tH\0R\x16httpQueryParameterName\x12*\n\x11minimum_\
    ring_size\x18\x04\x20\x01(\x04R\x0fminimumRingSize\x1ak\n\nHTTPCookie\
    \x12\x17\n\x04name\x18\x01\x20\x01(\tR\x04nameB\x03\xe0A\x02\x12\x12\n\
    \x04path\x18\x02\x20\x01(\tR\x04path\x120\n\x03ttl\x18\x03\x20\x01(\x0b2\
    \x19.google.protobuf.DurationR\x03ttlB\x03\xe0A\x02B\n\n\x08hash_key\"p\
    \n\x08SimpleLB\x12\x0f\n\x0bUNSPECIFIED\x10\0\x12\x12\n\nLEAST_CONN\x10\
    \x01\x1a\x02\x08\x01\x12\n\n\x06RANDOM\x10\x02\x12\x0f\n\x0bPASSTHROUGH\
    \x10\x03\x12\x0f\n\x0bROUND_ROBIN\x10\x04\x12\x11\n\rLEAST_REQUEST\x10\
    \x05B\x0b\n\tlb_policy\"\xbd\x08\n\x16ConnectionPoolSettings\x12N\n\x03t\
    cp\x18\x01\x20\x01(\x0b2<.istio.networking.v1beta1.ConnectionPoolSetting\
    s.TCPSettingsR\x03tcp\x12Q\n\x04http\x18\x02\x20\x01(\x0b2=.istio.networ\
    king.v1beta1.ConnectionPoolSettings.HTTPSettingsR\x04http\x1a\xf9\x02\n\
    \x0bTCPSettings\x12'\n\x0fmax_connections\x18\x01\x20\x01(\x05R\x0emaxCo\
    nnections\x12B\n\x0fconnect_timeout\x18\x02\x20\x01(\x0b2\x19.google.pro\
    tobuf.DurationR\x0econnectTimeout\x12n\n\rtcp_keepalive\x18\x03\x20\x01(\
    \x0b2I.istio.networking.v1beta1.ConnectionPoolSettings.TCPSettings.TcpKe\
    epaliveR\x0ctcpKeepalive\x1a\x8c\x01\n\x0cTcpKeepalive\x12\x16\n\x06prob\
    es\x18\x01\x20\x01(\rR\x06probes\x12-\n\x04time\x18\x02\x20\x01(\x0b2\
    \x19.google.protobuf.DurationR\x04time\x125\n\x08interval\x18\x03\x20\
    \x01(\x0b2\x19.google.protobuf.DurationR\x08interval\x1a\x83\x04\n\x0cHT\
    TPSettings\x12;\n\x1ahttp1_max_pending_requests\x18\x01\x20\x01(\x05R\
    \x17http1MaxPendingRequests\x12,\n\x12http2_max_requests\x18\x02\x20\x01\
    (\x05R\x10http2MaxRequests\x12=\n\x1bmax_requests_per_connection\x18\x03\
    \x20\x01(\x05R\x18maxRequestsPerConnection\x12\x1f\n\x0bmax_retries\x18\
    \x04\x20\x01(\x05R\nmaxRetries\x12<\n\x0cidle_timeout\x18\x05\x20\x01(\
    \x0b2\x19.google.protobuf.DurationR\x0bidleTimeout\x12y\n\x11h2_upgrade_\
    policy\x18\x06\x20\x01(\x0e2M.istio.networking.v1beta1.ConnectionPoolSet\
    tings.HTTPSettings.H2UpgradePolicyR\x0fh2UpgradePolicy\x12.\n\x13use_cli\
    ent_protocol\x18\x07\x20\x01(\x08R\x11useClientProtocol\"?\n\x0fH2Upgrad\
    ePolicy\x12\x0b\n\x07DEFAULT\x10\0\x12\x12\n\x0eDO_NOT_UPGRADE\x10\x01\
    \x12\x0b\n\x07UPGRADE\x10\x02\"\x8a\x05\n\x10OutlierDetection\x121\n\x12\
    consecutive_errors\x18\x01\x20\x01(\x05R\x11consecutiveErrorsB\x02\x18\
    \x01\x12J\n\"split_external_local_origin_errors\x18\x08\x20\x01(\x08R\
    \x1esplitExternalLocalOriginErrors\x12g\n!consecutive_local_origin_failu\
    res\x18\t\x20\x01(\x0b2\x1c.google.protobuf.UInt32ValueR\x1econsecutiveL\
    ocalOriginFailures\x12Z\n\x1aconsecutive_gateway_errors\x18\x06\x20\x01(\
    \x0b2\x1c.google.protobuf.UInt32ValueR\x18consecutiveGatewayErrors\x12R\
    \n\x16consecutive_5xx_errors\x18\x07\x20\x01(\x0b2\x1c.google.protobuf.U\
    Int32ValueR\x14consecutive5xxErrors\x125\n\x08interval\x18\x02\x20\x01(\
    \x0b2\x19.google.protobuf.DurationR\x08interval\x12G\n\x12base_ejection_\
    time\x18\x03\x20\x01(\x0b2\x19.google.protobuf.DurationR\x10baseEjection\
    Time\x120\n\x14max_ejection_percent\x18\x04\x20\x01(\x05R\x12maxEjection\
    Percent\x12,\n\x12min_health_percent\x18\x05\x20\x01(\x05R\x10minHealthP\
    ercent\"\xd1\x03\n\x11ClientTLSSettings\x12L\n\x04mode\x18\x01\x20\x01(\
    \x0e23.istio.networking.v1beta1.ClientTLSSettings.TLSmodeR\x04modeB\x03\
    \xe0A\x02\x12-\n\x12client_certificate\x18\x02\x20\x01(\tR\x11clientCert\
    ificate\x12\x1f\n\x0bprivate_key\x18\x03\x20\x01(\tR\nprivateKey\x12'\n\
    \x0fca_certificates\x18\x04\x20\x01(\tR\x0ecaCertificates\x12'\n\x0fcred\
    ential_name\x18\x07\x20\x01(\tR\x0ecredentialName\x12*\n\x11subject_alt_\
    names\x18\x05\x20\x03(\tR\x0fsubjectAltNames\x12\x10\n\x03sni\x18\x06\
    \x20\x01(\tR\x03sni\x12L\n\x14insecure_skip_verify\x18\x08\x20\x01(\x0b2\
    \x1a.google.protobuf.BoolValueR\x12insecureSkipVerify\"@\n\x07TLSmode\
    \x12\x0b\n\x07DISABLE\x10\0\x12\n\n\x06SIMPLE\x10\x01\x12\n\n\x06MUTUAL\
    \x10\x02\x12\x10\n\x0cISTIO_MUTUAL\x10\x03\"\xa2\x04\n\x1bLocalityLoadBa\
    lancerSetting\x12`\n\ndistribute\x18\x01\x20\x03(\x0b2@.istio.networking\
    .v1beta1.LocalityLoadBalancerSetting.DistributeR\ndistribute\x12Z\n\x08f\
    ailover\x18\x02\x20\x03(\x0b2>.istio.networking.v1beta1.LocalityLoadBala\
    ncerSetting.FailoverR\x08failover\x12+\n\x11failover_priority\x18\x04\
    \x20\x03(\tR\x10failoverPriority\x124\n\x07enabled\x18\x03\x20\x01(\x0b2\
    \x1a.google.protobuf.BoolValueR\x07enabled\x1a\xb1\x01\n\nDistribute\x12\
    \x12\n\x04from\x18\x01\x20\x01(\tR\x04from\x12X\n\x02to\x18\x02\x20\x03(\
    \x0b2H.istio.networking.v1beta1.LocalityLoadBalancerSetting.Distribute.T\
    oEntryR\x02to\x1a5\n\x07ToEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03\
    key\x12\x14\n\x05value\x18\x02\x20\x01(\rR\x05value:\x028\x01\x1a.\n\x08\
    Failover\x12\x12\n\x04from\x18\x01\x20\x01(\tR\x04from\x12\x0e\n\x02to\
    \x18\x02\x20\x01(\tR\x02toB!Z\x1fistio.io/api/networking/v1beta1b\x06pro\
    to3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
