// This file is generated by rust-protobuf 2.27.1. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `networking/v1beta1/virtual_service.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_27_1;

#[derive(PartialEq,Clone,Default)]
pub struct VirtualService {
    // message fields
    pub hosts: ::protobuf::RepeatedField<::std::string::String>,
    pub gateways: ::protobuf::RepeatedField<::std::string::String>,
    pub http: ::protobuf::RepeatedField<HTTPRoute>,
    pub tls: ::protobuf::RepeatedField<TLSRoute>,
    pub tcp: ::protobuf::RepeatedField<TCPRoute>,
    pub export_to: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VirtualService {
    fn default() -> &'a VirtualService {
        <VirtualService as ::protobuf::Message>::default_instance()
    }
}

impl VirtualService {
    pub fn new() -> VirtualService {
        ::std::default::Default::default()
    }

    // repeated string hosts = 1;


    pub fn get_hosts(&self) -> &[::std::string::String] {
        &self.hosts
    }
    pub fn clear_hosts(&mut self) {
        self.hosts.clear();
    }

    // Param is passed by value, moved
    pub fn set_hosts(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.hosts = v;
    }

    // Mutable pointer to the field.
    pub fn mut_hosts(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.hosts
    }

    // Take field
    pub fn take_hosts(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.hosts, ::protobuf::RepeatedField::new())
    }

    // repeated string gateways = 2;


    pub fn get_gateways(&self) -> &[::std::string::String] {
        &self.gateways
    }
    pub fn clear_gateways(&mut self) {
        self.gateways.clear();
    }

    // Param is passed by value, moved
    pub fn set_gateways(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.gateways = v;
    }

    // Mutable pointer to the field.
    pub fn mut_gateways(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.gateways
    }

    // Take field
    pub fn take_gateways(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.gateways, ::protobuf::RepeatedField::new())
    }

    // repeated .istio.networking.v1beta1.HTTPRoute http = 3;


    pub fn get_http(&self) -> &[HTTPRoute] {
        &self.http
    }
    pub fn clear_http(&mut self) {
        self.http.clear();
    }

    // Param is passed by value, moved
    pub fn set_http(&mut self, v: ::protobuf::RepeatedField<HTTPRoute>) {
        self.http = v;
    }

    // Mutable pointer to the field.
    pub fn mut_http(&mut self) -> &mut ::protobuf::RepeatedField<HTTPRoute> {
        &mut self.http
    }

    // Take field
    pub fn take_http(&mut self) -> ::protobuf::RepeatedField<HTTPRoute> {
        ::std::mem::replace(&mut self.http, ::protobuf::RepeatedField::new())
    }

    // repeated .istio.networking.v1beta1.TLSRoute tls = 5;


    pub fn get_tls(&self) -> &[TLSRoute] {
        &self.tls
    }
    pub fn clear_tls(&mut self) {
        self.tls.clear();
    }

    // Param is passed by value, moved
    pub fn set_tls(&mut self, v: ::protobuf::RepeatedField<TLSRoute>) {
        self.tls = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tls(&mut self) -> &mut ::protobuf::RepeatedField<TLSRoute> {
        &mut self.tls
    }

    // Take field
    pub fn take_tls(&mut self) -> ::protobuf::RepeatedField<TLSRoute> {
        ::std::mem::replace(&mut self.tls, ::protobuf::RepeatedField::new())
    }

    // repeated .istio.networking.v1beta1.TCPRoute tcp = 4;


    pub fn get_tcp(&self) -> &[TCPRoute] {
        &self.tcp
    }
    pub fn clear_tcp(&mut self) {
        self.tcp.clear();
    }

    // Param is passed by value, moved
    pub fn set_tcp(&mut self, v: ::protobuf::RepeatedField<TCPRoute>) {
        self.tcp = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tcp(&mut self) -> &mut ::protobuf::RepeatedField<TCPRoute> {
        &mut self.tcp
    }

    // Take field
    pub fn take_tcp(&mut self) -> ::protobuf::RepeatedField<TCPRoute> {
        ::std::mem::replace(&mut self.tcp, ::protobuf::RepeatedField::new())
    }

    // repeated string export_to = 6;


    pub fn get_export_to(&self) -> &[::std::string::String] {
        &self.export_to
    }
    pub fn clear_export_to(&mut self) {
        self.export_to.clear();
    }

    // Param is passed by value, moved
    pub fn set_export_to(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.export_to = v;
    }

    // Mutable pointer to the field.
    pub fn mut_export_to(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.export_to
    }

    // Take field
    pub fn take_export_to(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.export_to, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for VirtualService {
    fn is_initialized(&self) -> bool {
        for v in &self.http {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.tls {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.tcp {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.hosts)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.gateways)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.http)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.tls)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.tcp)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.export_to)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.hosts {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in &self.gateways {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in &self.http {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.tls {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.tcp {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.export_to {
            my_size += ::protobuf::rt::string_size(6, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.hosts {
            os.write_string(1, &v)?;
        };
        for v in &self.gateways {
            os.write_string(2, &v)?;
        };
        for v in &self.http {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.tls {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.tcp {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.export_to {
            os.write_string(6, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VirtualService {
        VirtualService::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "hosts",
                |m: &VirtualService| { &m.hosts },
                |m: &mut VirtualService| { &mut m.hosts },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "gateways",
                |m: &VirtualService| { &m.gateways },
                |m: &mut VirtualService| { &mut m.gateways },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<HTTPRoute>>(
                "http",
                |m: &VirtualService| { &m.http },
                |m: &mut VirtualService| { &mut m.http },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TLSRoute>>(
                "tls",
                |m: &VirtualService| { &m.tls },
                |m: &mut VirtualService| { &mut m.tls },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TCPRoute>>(
                "tcp",
                |m: &VirtualService| { &m.tcp },
                |m: &mut VirtualService| { &mut m.tcp },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "export_to",
                |m: &VirtualService| { &m.export_to },
                |m: &mut VirtualService| { &mut m.export_to },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VirtualService>(
                "VirtualService",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VirtualService {
        static instance: ::protobuf::rt::LazyV2<VirtualService> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VirtualService::new)
    }
}

impl ::protobuf::Clear for VirtualService {
    fn clear(&mut self) {
        self.hosts.clear();
        self.gateways.clear();
        self.http.clear();
        self.tls.clear();
        self.tcp.clear();
        self.export_to.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VirtualService {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VirtualService {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Destination {
    // message fields
    pub host: ::std::string::String,
    pub subset: ::std::string::String,
    pub port: ::protobuf::SingularPtrField<PortSelector>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Destination {
    fn default() -> &'a Destination {
        <Destination as ::protobuf::Message>::default_instance()
    }
}

impl Destination {
    pub fn new() -> Destination {
        ::std::default::Default::default()
    }

    // string host = 1;


    pub fn get_host(&self) -> &str {
        &self.host
    }
    pub fn clear_host(&mut self) {
        self.host.clear();
    }

    // Param is passed by value, moved
    pub fn set_host(&mut self, v: ::std::string::String) {
        self.host = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_host(&mut self) -> &mut ::std::string::String {
        &mut self.host
    }

    // Take field
    pub fn take_host(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.host, ::std::string::String::new())
    }

    // string subset = 2;


    pub fn get_subset(&self) -> &str {
        &self.subset
    }
    pub fn clear_subset(&mut self) {
        self.subset.clear();
    }

    // Param is passed by value, moved
    pub fn set_subset(&mut self, v: ::std::string::String) {
        self.subset = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_subset(&mut self) -> &mut ::std::string::String {
        &mut self.subset
    }

    // Take field
    pub fn take_subset(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.subset, ::std::string::String::new())
    }

    // .istio.networking.v1beta1.PortSelector port = 3;


    pub fn get_port(&self) -> &PortSelector {
        self.port.as_ref().unwrap_or_else(|| <PortSelector as ::protobuf::Message>::default_instance())
    }
    pub fn clear_port(&mut self) {
        self.port.clear();
    }

    pub fn has_port(&self) -> bool {
        self.port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_port(&mut self, v: PortSelector) {
        self.port = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_port(&mut self) -> &mut PortSelector {
        if self.port.is_none() {
            self.port.set_default();
        }
        self.port.as_mut().unwrap()
    }

    // Take field
    pub fn take_port(&mut self) -> PortSelector {
        self.port.take().unwrap_or_else(|| PortSelector::new())
    }
}

impl ::protobuf::Message for Destination {
    fn is_initialized(&self) -> bool {
        for v in &self.port {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.host)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.subset)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.port)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.host.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.host);
        }
        if !self.subset.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.subset);
        }
        if let Some(ref v) = self.port.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.host.is_empty() {
            os.write_string(1, &self.host)?;
        }
        if !self.subset.is_empty() {
            os.write_string(2, &self.subset)?;
        }
        if let Some(ref v) = self.port.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Destination {
        Destination::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "host",
                |m: &Destination| { &m.host },
                |m: &mut Destination| { &mut m.host },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "subset",
                |m: &Destination| { &m.subset },
                |m: &mut Destination| { &mut m.subset },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PortSelector>>(
                "port",
                |m: &Destination| { &m.port },
                |m: &mut Destination| { &mut m.port },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Destination>(
                "Destination",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Destination {
        static instance: ::protobuf::rt::LazyV2<Destination> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Destination::new)
    }
}

impl ::protobuf::Clear for Destination {
    fn clear(&mut self) {
        self.host.clear();
        self.subset.clear();
        self.port.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Destination {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Destination {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct HTTPRoute {
    // message fields
    pub name: ::std::string::String,
    pub field_match: ::protobuf::RepeatedField<HTTPMatchRequest>,
    pub route: ::protobuf::RepeatedField<HTTPRouteDestination>,
    pub redirect: ::protobuf::SingularPtrField<HTTPRedirect>,
    pub delegate: ::protobuf::SingularPtrField<Delegate>,
    pub rewrite: ::protobuf::SingularPtrField<HTTPRewrite>,
    pub timeout: ::protobuf::SingularPtrField<::protobuf::well_known_types::Duration>,
    pub retries: ::protobuf::SingularPtrField<HTTPRetry>,
    pub fault: ::protobuf::SingularPtrField<HTTPFaultInjection>,
    pub mirror: ::protobuf::SingularPtrField<Destination>,
    pub mirror_percent: ::protobuf::SingularPtrField<::protobuf::well_known_types::UInt32Value>,
    pub mirror_percentage: ::protobuf::SingularPtrField<Percent>,
    pub cors_policy: ::protobuf::SingularPtrField<CorsPolicy>,
    pub headers: ::protobuf::SingularPtrField<Headers>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HTTPRoute {
    fn default() -> &'a HTTPRoute {
        <HTTPRoute as ::protobuf::Message>::default_instance()
    }
}

impl HTTPRoute {
    pub fn new() -> HTTPRoute {
        ::std::default::Default::default()
    }

    // string name = 17;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // repeated .istio.networking.v1beta1.HTTPMatchRequest match = 1;


    pub fn get_field_match(&self) -> &[HTTPMatchRequest] {
        &self.field_match
    }
    pub fn clear_field_match(&mut self) {
        self.field_match.clear();
    }

    // Param is passed by value, moved
    pub fn set_field_match(&mut self, v: ::protobuf::RepeatedField<HTTPMatchRequest>) {
        self.field_match = v;
    }

    // Mutable pointer to the field.
    pub fn mut_field_match(&mut self) -> &mut ::protobuf::RepeatedField<HTTPMatchRequest> {
        &mut self.field_match
    }

    // Take field
    pub fn take_field_match(&mut self) -> ::protobuf::RepeatedField<HTTPMatchRequest> {
        ::std::mem::replace(&mut self.field_match, ::protobuf::RepeatedField::new())
    }

    // repeated .istio.networking.v1beta1.HTTPRouteDestination route = 2;


    pub fn get_route(&self) -> &[HTTPRouteDestination] {
        &self.route
    }
    pub fn clear_route(&mut self) {
        self.route.clear();
    }

    // Param is passed by value, moved
    pub fn set_route(&mut self, v: ::protobuf::RepeatedField<HTTPRouteDestination>) {
        self.route = v;
    }

    // Mutable pointer to the field.
    pub fn mut_route(&mut self) -> &mut ::protobuf::RepeatedField<HTTPRouteDestination> {
        &mut self.route
    }

    // Take field
    pub fn take_route(&mut self) -> ::protobuf::RepeatedField<HTTPRouteDestination> {
        ::std::mem::replace(&mut self.route, ::protobuf::RepeatedField::new())
    }

    // .istio.networking.v1beta1.HTTPRedirect redirect = 3;


    pub fn get_redirect(&self) -> &HTTPRedirect {
        self.redirect.as_ref().unwrap_or_else(|| <HTTPRedirect as ::protobuf::Message>::default_instance())
    }
    pub fn clear_redirect(&mut self) {
        self.redirect.clear();
    }

    pub fn has_redirect(&self) -> bool {
        self.redirect.is_some()
    }

    // Param is passed by value, moved
    pub fn set_redirect(&mut self, v: HTTPRedirect) {
        self.redirect = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_redirect(&mut self) -> &mut HTTPRedirect {
        if self.redirect.is_none() {
            self.redirect.set_default();
        }
        self.redirect.as_mut().unwrap()
    }

    // Take field
    pub fn take_redirect(&mut self) -> HTTPRedirect {
        self.redirect.take().unwrap_or_else(|| HTTPRedirect::new())
    }

    // .istio.networking.v1beta1.Delegate delegate = 20;


    pub fn get_delegate(&self) -> &Delegate {
        self.delegate.as_ref().unwrap_or_else(|| <Delegate as ::protobuf::Message>::default_instance())
    }
    pub fn clear_delegate(&mut self) {
        self.delegate.clear();
    }

    pub fn has_delegate(&self) -> bool {
        self.delegate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_delegate(&mut self, v: Delegate) {
        self.delegate = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_delegate(&mut self) -> &mut Delegate {
        if self.delegate.is_none() {
            self.delegate.set_default();
        }
        self.delegate.as_mut().unwrap()
    }

    // Take field
    pub fn take_delegate(&mut self) -> Delegate {
        self.delegate.take().unwrap_or_else(|| Delegate::new())
    }

    // .istio.networking.v1beta1.HTTPRewrite rewrite = 4;


    pub fn get_rewrite(&self) -> &HTTPRewrite {
        self.rewrite.as_ref().unwrap_or_else(|| <HTTPRewrite as ::protobuf::Message>::default_instance())
    }
    pub fn clear_rewrite(&mut self) {
        self.rewrite.clear();
    }

    pub fn has_rewrite(&self) -> bool {
        self.rewrite.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rewrite(&mut self, v: HTTPRewrite) {
        self.rewrite = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rewrite(&mut self) -> &mut HTTPRewrite {
        if self.rewrite.is_none() {
            self.rewrite.set_default();
        }
        self.rewrite.as_mut().unwrap()
    }

    // Take field
    pub fn take_rewrite(&mut self) -> HTTPRewrite {
        self.rewrite.take().unwrap_or_else(|| HTTPRewrite::new())
    }

    // .google.protobuf.Duration timeout = 6;


    pub fn get_timeout(&self) -> &::protobuf::well_known_types::Duration {
        self.timeout.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Duration as ::protobuf::Message>::default_instance())
    }
    pub fn clear_timeout(&mut self) {
        self.timeout.clear();
    }

    pub fn has_timeout(&self) -> bool {
        self.timeout.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timeout(&mut self, v: ::protobuf::well_known_types::Duration) {
        self.timeout = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_timeout(&mut self) -> &mut ::protobuf::well_known_types::Duration {
        if self.timeout.is_none() {
            self.timeout.set_default();
        }
        self.timeout.as_mut().unwrap()
    }

    // Take field
    pub fn take_timeout(&mut self) -> ::protobuf::well_known_types::Duration {
        self.timeout.take().unwrap_or_else(|| ::protobuf::well_known_types::Duration::new())
    }

    // .istio.networking.v1beta1.HTTPRetry retries = 7;


    pub fn get_retries(&self) -> &HTTPRetry {
        self.retries.as_ref().unwrap_or_else(|| <HTTPRetry as ::protobuf::Message>::default_instance())
    }
    pub fn clear_retries(&mut self) {
        self.retries.clear();
    }

    pub fn has_retries(&self) -> bool {
        self.retries.is_some()
    }

    // Param is passed by value, moved
    pub fn set_retries(&mut self, v: HTTPRetry) {
        self.retries = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_retries(&mut self) -> &mut HTTPRetry {
        if self.retries.is_none() {
            self.retries.set_default();
        }
        self.retries.as_mut().unwrap()
    }

    // Take field
    pub fn take_retries(&mut self) -> HTTPRetry {
        self.retries.take().unwrap_or_else(|| HTTPRetry::new())
    }

    // .istio.networking.v1beta1.HTTPFaultInjection fault = 8;


    pub fn get_fault(&self) -> &HTTPFaultInjection {
        self.fault.as_ref().unwrap_or_else(|| <HTTPFaultInjection as ::protobuf::Message>::default_instance())
    }
    pub fn clear_fault(&mut self) {
        self.fault.clear();
    }

    pub fn has_fault(&self) -> bool {
        self.fault.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fault(&mut self, v: HTTPFaultInjection) {
        self.fault = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fault(&mut self) -> &mut HTTPFaultInjection {
        if self.fault.is_none() {
            self.fault.set_default();
        }
        self.fault.as_mut().unwrap()
    }

    // Take field
    pub fn take_fault(&mut self) -> HTTPFaultInjection {
        self.fault.take().unwrap_or_else(|| HTTPFaultInjection::new())
    }

    // .istio.networking.v1beta1.Destination mirror = 9;


    pub fn get_mirror(&self) -> &Destination {
        self.mirror.as_ref().unwrap_or_else(|| <Destination as ::protobuf::Message>::default_instance())
    }
    pub fn clear_mirror(&mut self) {
        self.mirror.clear();
    }

    pub fn has_mirror(&self) -> bool {
        self.mirror.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mirror(&mut self, v: Destination) {
        self.mirror = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mirror(&mut self) -> &mut Destination {
        if self.mirror.is_none() {
            self.mirror.set_default();
        }
        self.mirror.as_mut().unwrap()
    }

    // Take field
    pub fn take_mirror(&mut self) -> Destination {
        self.mirror.take().unwrap_or_else(|| Destination::new())
    }

    // .google.protobuf.UInt32Value mirror_percent = 18;


    pub fn get_mirror_percent(&self) -> &::protobuf::well_known_types::UInt32Value {
        self.mirror_percent.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::UInt32Value as ::protobuf::Message>::default_instance())
    }
    pub fn clear_mirror_percent(&mut self) {
        self.mirror_percent.clear();
    }

    pub fn has_mirror_percent(&self) -> bool {
        self.mirror_percent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mirror_percent(&mut self, v: ::protobuf::well_known_types::UInt32Value) {
        self.mirror_percent = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mirror_percent(&mut self) -> &mut ::protobuf::well_known_types::UInt32Value {
        if self.mirror_percent.is_none() {
            self.mirror_percent.set_default();
        }
        self.mirror_percent.as_mut().unwrap()
    }

    // Take field
    pub fn take_mirror_percent(&mut self) -> ::protobuf::well_known_types::UInt32Value {
        self.mirror_percent.take().unwrap_or_else(|| ::protobuf::well_known_types::UInt32Value::new())
    }

    // .istio.networking.v1beta1.Percent mirror_percentage = 19;


    pub fn get_mirror_percentage(&self) -> &Percent {
        self.mirror_percentage.as_ref().unwrap_or_else(|| <Percent as ::protobuf::Message>::default_instance())
    }
    pub fn clear_mirror_percentage(&mut self) {
        self.mirror_percentage.clear();
    }

    pub fn has_mirror_percentage(&self) -> bool {
        self.mirror_percentage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mirror_percentage(&mut self, v: Percent) {
        self.mirror_percentage = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mirror_percentage(&mut self) -> &mut Percent {
        if self.mirror_percentage.is_none() {
            self.mirror_percentage.set_default();
        }
        self.mirror_percentage.as_mut().unwrap()
    }

    // Take field
    pub fn take_mirror_percentage(&mut self) -> Percent {
        self.mirror_percentage.take().unwrap_or_else(|| Percent::new())
    }

    // .istio.networking.v1beta1.CorsPolicy cors_policy = 10;


    pub fn get_cors_policy(&self) -> &CorsPolicy {
        self.cors_policy.as_ref().unwrap_or_else(|| <CorsPolicy as ::protobuf::Message>::default_instance())
    }
    pub fn clear_cors_policy(&mut self) {
        self.cors_policy.clear();
    }

    pub fn has_cors_policy(&self) -> bool {
        self.cors_policy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cors_policy(&mut self, v: CorsPolicy) {
        self.cors_policy = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cors_policy(&mut self) -> &mut CorsPolicy {
        if self.cors_policy.is_none() {
            self.cors_policy.set_default();
        }
        self.cors_policy.as_mut().unwrap()
    }

    // Take field
    pub fn take_cors_policy(&mut self) -> CorsPolicy {
        self.cors_policy.take().unwrap_or_else(|| CorsPolicy::new())
    }

    // .istio.networking.v1beta1.Headers headers = 16;


    pub fn get_headers(&self) -> &Headers {
        self.headers.as_ref().unwrap_or_else(|| <Headers as ::protobuf::Message>::default_instance())
    }
    pub fn clear_headers(&mut self) {
        self.headers.clear();
    }

    pub fn has_headers(&self) -> bool {
        self.headers.is_some()
    }

    // Param is passed by value, moved
    pub fn set_headers(&mut self, v: Headers) {
        self.headers = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_headers(&mut self) -> &mut Headers {
        if self.headers.is_none() {
            self.headers.set_default();
        }
        self.headers.as_mut().unwrap()
    }

    // Take field
    pub fn take_headers(&mut self) -> Headers {
        self.headers.take().unwrap_or_else(|| Headers::new())
    }
}

impl ::protobuf::Message for HTTPRoute {
    fn is_initialized(&self) -> bool {
        for v in &self.field_match {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.route {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.redirect {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.delegate {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.rewrite {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.timeout {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.retries {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.fault {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.mirror {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.mirror_percent {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.mirror_percentage {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.cors_policy {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.headers {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                17 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.field_match)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.route)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.redirect)?;
                },
                20 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.delegate)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.rewrite)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.timeout)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.retries)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.fault)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.mirror)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.mirror_percent)?;
                },
                19 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.mirror_percentage)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.cors_policy)?;
                },
                16 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.headers)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(17, &self.name);
        }
        for value in &self.field_match {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.route {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.redirect.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.delegate.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.rewrite.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.timeout.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.retries.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.fault.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.mirror.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.mirror_percent.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.mirror_percentage.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.cors_policy.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.headers.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(17, &self.name)?;
        }
        for v in &self.field_match {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.route {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.redirect.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.delegate.as_ref() {
            os.write_tag(20, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.rewrite.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.timeout.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.retries.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.fault.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.mirror.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.mirror_percent.as_ref() {
            os.write_tag(18, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.mirror_percentage.as_ref() {
            os.write_tag(19, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.cors_policy.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.headers.as_ref() {
            os.write_tag(16, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HTTPRoute {
        HTTPRoute::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &HTTPRoute| { &m.name },
                |m: &mut HTTPRoute| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<HTTPMatchRequest>>(
                "match",
                |m: &HTTPRoute| { &m.field_match },
                |m: &mut HTTPRoute| { &mut m.field_match },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<HTTPRouteDestination>>(
                "route",
                |m: &HTTPRoute| { &m.route },
                |m: &mut HTTPRoute| { &mut m.route },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<HTTPRedirect>>(
                "redirect",
                |m: &HTTPRoute| { &m.redirect },
                |m: &mut HTTPRoute| { &mut m.redirect },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Delegate>>(
                "delegate",
                |m: &HTTPRoute| { &m.delegate },
                |m: &mut HTTPRoute| { &mut m.delegate },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<HTTPRewrite>>(
                "rewrite",
                |m: &HTTPRoute| { &m.rewrite },
                |m: &mut HTTPRoute| { &mut m.rewrite },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Duration>>(
                "timeout",
                |m: &HTTPRoute| { &m.timeout },
                |m: &mut HTTPRoute| { &mut m.timeout },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<HTTPRetry>>(
                "retries",
                |m: &HTTPRoute| { &m.retries },
                |m: &mut HTTPRoute| { &mut m.retries },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<HTTPFaultInjection>>(
                "fault",
                |m: &HTTPRoute| { &m.fault },
                |m: &mut HTTPRoute| { &mut m.fault },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Destination>>(
                "mirror",
                |m: &HTTPRoute| { &m.mirror },
                |m: &mut HTTPRoute| { &mut m.mirror },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::UInt32Value>>(
                "mirror_percent",
                |m: &HTTPRoute| { &m.mirror_percent },
                |m: &mut HTTPRoute| { &mut m.mirror_percent },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Percent>>(
                "mirror_percentage",
                |m: &HTTPRoute| { &m.mirror_percentage },
                |m: &mut HTTPRoute| { &mut m.mirror_percentage },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CorsPolicy>>(
                "cors_policy",
                |m: &HTTPRoute| { &m.cors_policy },
                |m: &mut HTTPRoute| { &mut m.cors_policy },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Headers>>(
                "headers",
                |m: &HTTPRoute| { &m.headers },
                |m: &mut HTTPRoute| { &mut m.headers },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<HTTPRoute>(
                "HTTPRoute",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static HTTPRoute {
        static instance: ::protobuf::rt::LazyV2<HTTPRoute> = ::protobuf::rt::LazyV2::INIT;
        instance.get(HTTPRoute::new)
    }
}

impl ::protobuf::Clear for HTTPRoute {
    fn clear(&mut self) {
        self.name.clear();
        self.field_match.clear();
        self.route.clear();
        self.redirect.clear();
        self.delegate.clear();
        self.rewrite.clear();
        self.timeout.clear();
        self.retries.clear();
        self.fault.clear();
        self.mirror.clear();
        self.mirror_percent.clear();
        self.mirror_percentage.clear();
        self.cors_policy.clear();
        self.headers.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HTTPRoute {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HTTPRoute {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Delegate {
    // message fields
    pub name: ::std::string::String,
    pub namespace: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Delegate {
    fn default() -> &'a Delegate {
        <Delegate as ::protobuf::Message>::default_instance()
    }
}

impl Delegate {
    pub fn new() -> Delegate {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string namespace = 2;


    pub fn get_namespace(&self) -> &str {
        &self.namespace
    }
    pub fn clear_namespace(&mut self) {
        self.namespace.clear();
    }

    // Param is passed by value, moved
    pub fn set_namespace(&mut self, v: ::std::string::String) {
        self.namespace = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_namespace(&mut self) -> &mut ::std::string::String {
        &mut self.namespace
    }

    // Take field
    pub fn take_namespace(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.namespace, ::std::string::String::new())
    }
}

impl ::protobuf::Message for Delegate {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.namespace)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if !self.namespace.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.namespace);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.namespace.is_empty() {
            os.write_string(2, &self.namespace)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Delegate {
        Delegate::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &Delegate| { &m.name },
                |m: &mut Delegate| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "namespace",
                |m: &Delegate| { &m.namespace },
                |m: &mut Delegate| { &mut m.namespace },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Delegate>(
                "Delegate",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Delegate {
        static instance: ::protobuf::rt::LazyV2<Delegate> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Delegate::new)
    }
}

impl ::protobuf::Clear for Delegate {
    fn clear(&mut self) {
        self.name.clear();
        self.namespace.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Delegate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Delegate {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Headers {
    // message fields
    pub request: ::protobuf::SingularPtrField<Headers_HeaderOperations>,
    pub response: ::protobuf::SingularPtrField<Headers_HeaderOperations>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Headers {
    fn default() -> &'a Headers {
        <Headers as ::protobuf::Message>::default_instance()
    }
}

impl Headers {
    pub fn new() -> Headers {
        ::std::default::Default::default()
    }

    // .istio.networking.v1beta1.Headers.HeaderOperations request = 1;


    pub fn get_request(&self) -> &Headers_HeaderOperations {
        self.request.as_ref().unwrap_or_else(|| <Headers_HeaderOperations as ::protobuf::Message>::default_instance())
    }
    pub fn clear_request(&mut self) {
        self.request.clear();
    }

    pub fn has_request(&self) -> bool {
        self.request.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request(&mut self, v: Headers_HeaderOperations) {
        self.request = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_request(&mut self) -> &mut Headers_HeaderOperations {
        if self.request.is_none() {
            self.request.set_default();
        }
        self.request.as_mut().unwrap()
    }

    // Take field
    pub fn take_request(&mut self) -> Headers_HeaderOperations {
        self.request.take().unwrap_or_else(|| Headers_HeaderOperations::new())
    }

    // .istio.networking.v1beta1.Headers.HeaderOperations response = 2;


    pub fn get_response(&self) -> &Headers_HeaderOperations {
        self.response.as_ref().unwrap_or_else(|| <Headers_HeaderOperations as ::protobuf::Message>::default_instance())
    }
    pub fn clear_response(&mut self) {
        self.response.clear();
    }

    pub fn has_response(&self) -> bool {
        self.response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response(&mut self, v: Headers_HeaderOperations) {
        self.response = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_response(&mut self) -> &mut Headers_HeaderOperations {
        if self.response.is_none() {
            self.response.set_default();
        }
        self.response.as_mut().unwrap()
    }

    // Take field
    pub fn take_response(&mut self) -> Headers_HeaderOperations {
        self.response.take().unwrap_or_else(|| Headers_HeaderOperations::new())
    }
}

impl ::protobuf::Message for Headers {
    fn is_initialized(&self) -> bool {
        for v in &self.request {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.response {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.request)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.response)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.request.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.response.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.request.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.response.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Headers {
        Headers::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Headers_HeaderOperations>>(
                "request",
                |m: &Headers| { &m.request },
                |m: &mut Headers| { &mut m.request },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Headers_HeaderOperations>>(
                "response",
                |m: &Headers| { &m.response },
                |m: &mut Headers| { &mut m.response },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Headers>(
                "Headers",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Headers {
        static instance: ::protobuf::rt::LazyV2<Headers> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Headers::new)
    }
}

impl ::protobuf::Clear for Headers {
    fn clear(&mut self) {
        self.request.clear();
        self.response.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Headers {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Headers {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Headers_HeaderOperations {
    // message fields
    pub set: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    pub add: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    pub remove: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Headers_HeaderOperations {
    fn default() -> &'a Headers_HeaderOperations {
        <Headers_HeaderOperations as ::protobuf::Message>::default_instance()
    }
}

impl Headers_HeaderOperations {
    pub fn new() -> Headers_HeaderOperations {
        ::std::default::Default::default()
    }

    // repeated .istio.networking.v1beta1.Headers.HeaderOperations.SetEntry set = 1;


    pub fn get_set(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.set
    }
    pub fn clear_set(&mut self) {
        self.set.clear();
    }

    // Param is passed by value, moved
    pub fn set_set(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.set = v;
    }

    // Mutable pointer to the field.
    pub fn mut_set(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.set
    }

    // Take field
    pub fn take_set(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.set, ::std::collections::HashMap::new())
    }

    // repeated .istio.networking.v1beta1.Headers.HeaderOperations.AddEntry add = 2;


    pub fn get_add(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.add
    }
    pub fn clear_add(&mut self) {
        self.add.clear();
    }

    // Param is passed by value, moved
    pub fn set_add(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.add = v;
    }

    // Mutable pointer to the field.
    pub fn mut_add(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.add
    }

    // Take field
    pub fn take_add(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.add, ::std::collections::HashMap::new())
    }

    // repeated string remove = 3;


    pub fn get_remove(&self) -> &[::std::string::String] {
        &self.remove
    }
    pub fn clear_remove(&mut self) {
        self.remove.clear();
    }

    // Param is passed by value, moved
    pub fn set_remove(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.remove = v;
    }

    // Mutable pointer to the field.
    pub fn mut_remove(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.remove
    }

    // Take field
    pub fn take_remove(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.remove, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Headers_HeaderOperations {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.set)?;
                },
                2 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.add)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.remove)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(1, &self.set);
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(2, &self.add);
        for value in &self.remove {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(1, &self.set, os)?;
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(2, &self.add, os)?;
        for v in &self.remove {
            os.write_string(3, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Headers_HeaderOperations {
        Headers_HeaderOperations::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                "set",
                |m: &Headers_HeaderOperations| { &m.set },
                |m: &mut Headers_HeaderOperations| { &mut m.set },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                "add",
                |m: &Headers_HeaderOperations| { &m.add },
                |m: &mut Headers_HeaderOperations| { &mut m.add },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "remove",
                |m: &Headers_HeaderOperations| { &m.remove },
                |m: &mut Headers_HeaderOperations| { &mut m.remove },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Headers_HeaderOperations>(
                "Headers.HeaderOperations",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Headers_HeaderOperations {
        static instance: ::protobuf::rt::LazyV2<Headers_HeaderOperations> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Headers_HeaderOperations::new)
    }
}

impl ::protobuf::Clear for Headers_HeaderOperations {
    fn clear(&mut self) {
        self.set.clear();
        self.add.clear();
        self.remove.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Headers_HeaderOperations {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Headers_HeaderOperations {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TLSRoute {
    // message fields
    pub field_match: ::protobuf::RepeatedField<TLSMatchAttributes>,
    pub route: ::protobuf::RepeatedField<RouteDestination>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TLSRoute {
    fn default() -> &'a TLSRoute {
        <TLSRoute as ::protobuf::Message>::default_instance()
    }
}

impl TLSRoute {
    pub fn new() -> TLSRoute {
        ::std::default::Default::default()
    }

    // repeated .istio.networking.v1beta1.TLSMatchAttributes match = 1;


    pub fn get_field_match(&self) -> &[TLSMatchAttributes] {
        &self.field_match
    }
    pub fn clear_field_match(&mut self) {
        self.field_match.clear();
    }

    // Param is passed by value, moved
    pub fn set_field_match(&mut self, v: ::protobuf::RepeatedField<TLSMatchAttributes>) {
        self.field_match = v;
    }

    // Mutable pointer to the field.
    pub fn mut_field_match(&mut self) -> &mut ::protobuf::RepeatedField<TLSMatchAttributes> {
        &mut self.field_match
    }

    // Take field
    pub fn take_field_match(&mut self) -> ::protobuf::RepeatedField<TLSMatchAttributes> {
        ::std::mem::replace(&mut self.field_match, ::protobuf::RepeatedField::new())
    }

    // repeated .istio.networking.v1beta1.RouteDestination route = 2;


    pub fn get_route(&self) -> &[RouteDestination] {
        &self.route
    }
    pub fn clear_route(&mut self) {
        self.route.clear();
    }

    // Param is passed by value, moved
    pub fn set_route(&mut self, v: ::protobuf::RepeatedField<RouteDestination>) {
        self.route = v;
    }

    // Mutable pointer to the field.
    pub fn mut_route(&mut self) -> &mut ::protobuf::RepeatedField<RouteDestination> {
        &mut self.route
    }

    // Take field
    pub fn take_route(&mut self) -> ::protobuf::RepeatedField<RouteDestination> {
        ::std::mem::replace(&mut self.route, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for TLSRoute {
    fn is_initialized(&self) -> bool {
        for v in &self.field_match {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.route {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.field_match)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.route)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.field_match {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.route {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.field_match {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.route {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TLSRoute {
        TLSRoute::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TLSMatchAttributes>>(
                "match",
                |m: &TLSRoute| { &m.field_match },
                |m: &mut TLSRoute| { &mut m.field_match },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RouteDestination>>(
                "route",
                |m: &TLSRoute| { &m.route },
                |m: &mut TLSRoute| { &mut m.route },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TLSRoute>(
                "TLSRoute",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TLSRoute {
        static instance: ::protobuf::rt::LazyV2<TLSRoute> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TLSRoute::new)
    }
}

impl ::protobuf::Clear for TLSRoute {
    fn clear(&mut self) {
        self.field_match.clear();
        self.route.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TLSRoute {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TLSRoute {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TCPRoute {
    // message fields
    pub field_match: ::protobuf::RepeatedField<L4MatchAttributes>,
    pub route: ::protobuf::RepeatedField<RouteDestination>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TCPRoute {
    fn default() -> &'a TCPRoute {
        <TCPRoute as ::protobuf::Message>::default_instance()
    }
}

impl TCPRoute {
    pub fn new() -> TCPRoute {
        ::std::default::Default::default()
    }

    // repeated .istio.networking.v1beta1.L4MatchAttributes match = 1;


    pub fn get_field_match(&self) -> &[L4MatchAttributes] {
        &self.field_match
    }
    pub fn clear_field_match(&mut self) {
        self.field_match.clear();
    }

    // Param is passed by value, moved
    pub fn set_field_match(&mut self, v: ::protobuf::RepeatedField<L4MatchAttributes>) {
        self.field_match = v;
    }

    // Mutable pointer to the field.
    pub fn mut_field_match(&mut self) -> &mut ::protobuf::RepeatedField<L4MatchAttributes> {
        &mut self.field_match
    }

    // Take field
    pub fn take_field_match(&mut self) -> ::protobuf::RepeatedField<L4MatchAttributes> {
        ::std::mem::replace(&mut self.field_match, ::protobuf::RepeatedField::new())
    }

    // repeated .istio.networking.v1beta1.RouteDestination route = 2;


    pub fn get_route(&self) -> &[RouteDestination] {
        &self.route
    }
    pub fn clear_route(&mut self) {
        self.route.clear();
    }

    // Param is passed by value, moved
    pub fn set_route(&mut self, v: ::protobuf::RepeatedField<RouteDestination>) {
        self.route = v;
    }

    // Mutable pointer to the field.
    pub fn mut_route(&mut self) -> &mut ::protobuf::RepeatedField<RouteDestination> {
        &mut self.route
    }

    // Take field
    pub fn take_route(&mut self) -> ::protobuf::RepeatedField<RouteDestination> {
        ::std::mem::replace(&mut self.route, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for TCPRoute {
    fn is_initialized(&self) -> bool {
        for v in &self.field_match {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.route {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.field_match)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.route)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.field_match {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.route {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.field_match {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.route {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TCPRoute {
        TCPRoute::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<L4MatchAttributes>>(
                "match",
                |m: &TCPRoute| { &m.field_match },
                |m: &mut TCPRoute| { &mut m.field_match },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RouteDestination>>(
                "route",
                |m: &TCPRoute| { &m.route },
                |m: &mut TCPRoute| { &mut m.route },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TCPRoute>(
                "TCPRoute",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TCPRoute {
        static instance: ::protobuf::rt::LazyV2<TCPRoute> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TCPRoute::new)
    }
}

impl ::protobuf::Clear for TCPRoute {
    fn clear(&mut self) {
        self.field_match.clear();
        self.route.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TCPRoute {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TCPRoute {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct HTTPMatchRequest {
    // message fields
    pub name: ::std::string::String,
    pub uri: ::protobuf::SingularPtrField<StringMatch>,
    pub scheme: ::protobuf::SingularPtrField<StringMatch>,
    pub method: ::protobuf::SingularPtrField<StringMatch>,
    pub authority: ::protobuf::SingularPtrField<StringMatch>,
    pub headers: ::std::collections::HashMap<::std::string::String, StringMatch>,
    pub port: u32,
    pub source_labels: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    pub gateways: ::protobuf::RepeatedField<::std::string::String>,
    pub query_params: ::std::collections::HashMap<::std::string::String, StringMatch>,
    pub ignore_uri_case: bool,
    pub without_headers: ::std::collections::HashMap<::std::string::String, StringMatch>,
    pub source_namespace: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HTTPMatchRequest {
    fn default() -> &'a HTTPMatchRequest {
        <HTTPMatchRequest as ::protobuf::Message>::default_instance()
    }
}

impl HTTPMatchRequest {
    pub fn new() -> HTTPMatchRequest {
        ::std::default::Default::default()
    }

    // string name = 11;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // .istio.networking.v1beta1.StringMatch uri = 1;


    pub fn get_uri(&self) -> &StringMatch {
        self.uri.as_ref().unwrap_or_else(|| <StringMatch as ::protobuf::Message>::default_instance())
    }
    pub fn clear_uri(&mut self) {
        self.uri.clear();
    }

    pub fn has_uri(&self) -> bool {
        self.uri.is_some()
    }

    // Param is passed by value, moved
    pub fn set_uri(&mut self, v: StringMatch) {
        self.uri = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_uri(&mut self) -> &mut StringMatch {
        if self.uri.is_none() {
            self.uri.set_default();
        }
        self.uri.as_mut().unwrap()
    }

    // Take field
    pub fn take_uri(&mut self) -> StringMatch {
        self.uri.take().unwrap_or_else(|| StringMatch::new())
    }

    // .istio.networking.v1beta1.StringMatch scheme = 2;


    pub fn get_scheme(&self) -> &StringMatch {
        self.scheme.as_ref().unwrap_or_else(|| <StringMatch as ::protobuf::Message>::default_instance())
    }
    pub fn clear_scheme(&mut self) {
        self.scheme.clear();
    }

    pub fn has_scheme(&self) -> bool {
        self.scheme.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scheme(&mut self, v: StringMatch) {
        self.scheme = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_scheme(&mut self) -> &mut StringMatch {
        if self.scheme.is_none() {
            self.scheme.set_default();
        }
        self.scheme.as_mut().unwrap()
    }

    // Take field
    pub fn take_scheme(&mut self) -> StringMatch {
        self.scheme.take().unwrap_or_else(|| StringMatch::new())
    }

    // .istio.networking.v1beta1.StringMatch method = 3;


    pub fn get_method(&self) -> &StringMatch {
        self.method.as_ref().unwrap_or_else(|| <StringMatch as ::protobuf::Message>::default_instance())
    }
    pub fn clear_method(&mut self) {
        self.method.clear();
    }

    pub fn has_method(&self) -> bool {
        self.method.is_some()
    }

    // Param is passed by value, moved
    pub fn set_method(&mut self, v: StringMatch) {
        self.method = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_method(&mut self) -> &mut StringMatch {
        if self.method.is_none() {
            self.method.set_default();
        }
        self.method.as_mut().unwrap()
    }

    // Take field
    pub fn take_method(&mut self) -> StringMatch {
        self.method.take().unwrap_or_else(|| StringMatch::new())
    }

    // .istio.networking.v1beta1.StringMatch authority = 4;


    pub fn get_authority(&self) -> &StringMatch {
        self.authority.as_ref().unwrap_or_else(|| <StringMatch as ::protobuf::Message>::default_instance())
    }
    pub fn clear_authority(&mut self) {
        self.authority.clear();
    }

    pub fn has_authority(&self) -> bool {
        self.authority.is_some()
    }

    // Param is passed by value, moved
    pub fn set_authority(&mut self, v: StringMatch) {
        self.authority = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_authority(&mut self) -> &mut StringMatch {
        if self.authority.is_none() {
            self.authority.set_default();
        }
        self.authority.as_mut().unwrap()
    }

    // Take field
    pub fn take_authority(&mut self) -> StringMatch {
        self.authority.take().unwrap_or_else(|| StringMatch::new())
    }

    // repeated .istio.networking.v1beta1.HTTPMatchRequest.HeadersEntry headers = 5;


    pub fn get_headers(&self) -> &::std::collections::HashMap<::std::string::String, StringMatch> {
        &self.headers
    }
    pub fn clear_headers(&mut self) {
        self.headers.clear();
    }

    // Param is passed by value, moved
    pub fn set_headers(&mut self, v: ::std::collections::HashMap<::std::string::String, StringMatch>) {
        self.headers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_headers(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, StringMatch> {
        &mut self.headers
    }

    // Take field
    pub fn take_headers(&mut self) -> ::std::collections::HashMap<::std::string::String, StringMatch> {
        ::std::mem::replace(&mut self.headers, ::std::collections::HashMap::new())
    }

    // uint32 port = 6;


    pub fn get_port(&self) -> u32 {
        self.port
    }
    pub fn clear_port(&mut self) {
        self.port = 0;
    }

    // Param is passed by value, moved
    pub fn set_port(&mut self, v: u32) {
        self.port = v;
    }

    // repeated .istio.networking.v1beta1.HTTPMatchRequest.SourceLabelsEntry source_labels = 7;


    pub fn get_source_labels(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.source_labels
    }
    pub fn clear_source_labels(&mut self) {
        self.source_labels.clear();
    }

    // Param is passed by value, moved
    pub fn set_source_labels(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.source_labels = v;
    }

    // Mutable pointer to the field.
    pub fn mut_source_labels(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.source_labels
    }

    // Take field
    pub fn take_source_labels(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.source_labels, ::std::collections::HashMap::new())
    }

    // repeated string gateways = 8;


    pub fn get_gateways(&self) -> &[::std::string::String] {
        &self.gateways
    }
    pub fn clear_gateways(&mut self) {
        self.gateways.clear();
    }

    // Param is passed by value, moved
    pub fn set_gateways(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.gateways = v;
    }

    // Mutable pointer to the field.
    pub fn mut_gateways(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.gateways
    }

    // Take field
    pub fn take_gateways(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.gateways, ::protobuf::RepeatedField::new())
    }

    // repeated .istio.networking.v1beta1.HTTPMatchRequest.QueryParamsEntry query_params = 9;


    pub fn get_query_params(&self) -> &::std::collections::HashMap<::std::string::String, StringMatch> {
        &self.query_params
    }
    pub fn clear_query_params(&mut self) {
        self.query_params.clear();
    }

    // Param is passed by value, moved
    pub fn set_query_params(&mut self, v: ::std::collections::HashMap<::std::string::String, StringMatch>) {
        self.query_params = v;
    }

    // Mutable pointer to the field.
    pub fn mut_query_params(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, StringMatch> {
        &mut self.query_params
    }

    // Take field
    pub fn take_query_params(&mut self) -> ::std::collections::HashMap<::std::string::String, StringMatch> {
        ::std::mem::replace(&mut self.query_params, ::std::collections::HashMap::new())
    }

    // bool ignore_uri_case = 10;


    pub fn get_ignore_uri_case(&self) -> bool {
        self.ignore_uri_case
    }
    pub fn clear_ignore_uri_case(&mut self) {
        self.ignore_uri_case = false;
    }

    // Param is passed by value, moved
    pub fn set_ignore_uri_case(&mut self, v: bool) {
        self.ignore_uri_case = v;
    }

    // repeated .istio.networking.v1beta1.HTTPMatchRequest.WithoutHeadersEntry without_headers = 12;


    pub fn get_without_headers(&self) -> &::std::collections::HashMap<::std::string::String, StringMatch> {
        &self.without_headers
    }
    pub fn clear_without_headers(&mut self) {
        self.without_headers.clear();
    }

    // Param is passed by value, moved
    pub fn set_without_headers(&mut self, v: ::std::collections::HashMap<::std::string::String, StringMatch>) {
        self.without_headers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_without_headers(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, StringMatch> {
        &mut self.without_headers
    }

    // Take field
    pub fn take_without_headers(&mut self) -> ::std::collections::HashMap<::std::string::String, StringMatch> {
        ::std::mem::replace(&mut self.without_headers, ::std::collections::HashMap::new())
    }

    // string source_namespace = 13;


    pub fn get_source_namespace(&self) -> &str {
        &self.source_namespace
    }
    pub fn clear_source_namespace(&mut self) {
        self.source_namespace.clear();
    }

    // Param is passed by value, moved
    pub fn set_source_namespace(&mut self, v: ::std::string::String) {
        self.source_namespace = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_source_namespace(&mut self) -> &mut ::std::string::String {
        &mut self.source_namespace
    }

    // Take field
    pub fn take_source_namespace(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.source_namespace, ::std::string::String::new())
    }
}

impl ::protobuf::Message for HTTPMatchRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.uri {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.scheme {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.method {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.authority {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                11 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.uri)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.scheme)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.method)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.authority)?;
                },
                5 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<StringMatch>>(wire_type, is, &mut self.headers)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.port = tmp;
                },
                7 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.source_labels)?;
                },
                8 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.gateways)?;
                },
                9 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<StringMatch>>(wire_type, is, &mut self.query_params)?;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.ignore_uri_case = tmp;
                },
                12 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<StringMatch>>(wire_type, is, &mut self.without_headers)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.source_namespace)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(11, &self.name);
        }
        if let Some(ref v) = self.uri.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.scheme.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.method.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.authority.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<StringMatch>>(5, &self.headers);
        if self.port != 0 {
            my_size += ::protobuf::rt::value_size(6, self.port, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(7, &self.source_labels);
        for value in &self.gateways {
            my_size += ::protobuf::rt::string_size(8, &value);
        };
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<StringMatch>>(9, &self.query_params);
        if self.ignore_uri_case != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<StringMatch>>(12, &self.without_headers);
        if !self.source_namespace.is_empty() {
            my_size += ::protobuf::rt::string_size(13, &self.source_namespace);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(11, &self.name)?;
        }
        if let Some(ref v) = self.uri.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.scheme.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.method.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.authority.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<StringMatch>>(5, &self.headers, os)?;
        if self.port != 0 {
            os.write_uint32(6, self.port)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(7, &self.source_labels, os)?;
        for v in &self.gateways {
            os.write_string(8, &v)?;
        };
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<StringMatch>>(9, &self.query_params, os)?;
        if self.ignore_uri_case != false {
            os.write_bool(10, self.ignore_uri_case)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<StringMatch>>(12, &self.without_headers, os)?;
        if !self.source_namespace.is_empty() {
            os.write_string(13, &self.source_namespace)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HTTPMatchRequest {
        HTTPMatchRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &HTTPMatchRequest| { &m.name },
                |m: &mut HTTPMatchRequest| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<StringMatch>>(
                "uri",
                |m: &HTTPMatchRequest| { &m.uri },
                |m: &mut HTTPMatchRequest| { &mut m.uri },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<StringMatch>>(
                "scheme",
                |m: &HTTPMatchRequest| { &m.scheme },
                |m: &mut HTTPMatchRequest| { &mut m.scheme },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<StringMatch>>(
                "method",
                |m: &HTTPMatchRequest| { &m.method },
                |m: &mut HTTPMatchRequest| { &mut m.method },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<StringMatch>>(
                "authority",
                |m: &HTTPMatchRequest| { &m.authority },
                |m: &mut HTTPMatchRequest| { &mut m.authority },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<StringMatch>>(
                "headers",
                |m: &HTTPMatchRequest| { &m.headers },
                |m: &mut HTTPMatchRequest| { &mut m.headers },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "port",
                |m: &HTTPMatchRequest| { &m.port },
                |m: &mut HTTPMatchRequest| { &mut m.port },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                "source_labels",
                |m: &HTTPMatchRequest| { &m.source_labels },
                |m: &mut HTTPMatchRequest| { &mut m.source_labels },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "gateways",
                |m: &HTTPMatchRequest| { &m.gateways },
                |m: &mut HTTPMatchRequest| { &mut m.gateways },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<StringMatch>>(
                "query_params",
                |m: &HTTPMatchRequest| { &m.query_params },
                |m: &mut HTTPMatchRequest| { &mut m.query_params },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "ignore_uri_case",
                |m: &HTTPMatchRequest| { &m.ignore_uri_case },
                |m: &mut HTTPMatchRequest| { &mut m.ignore_uri_case },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<StringMatch>>(
                "without_headers",
                |m: &HTTPMatchRequest| { &m.without_headers },
                |m: &mut HTTPMatchRequest| { &mut m.without_headers },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "source_namespace",
                |m: &HTTPMatchRequest| { &m.source_namespace },
                |m: &mut HTTPMatchRequest| { &mut m.source_namespace },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<HTTPMatchRequest>(
                "HTTPMatchRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static HTTPMatchRequest {
        static instance: ::protobuf::rt::LazyV2<HTTPMatchRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(HTTPMatchRequest::new)
    }
}

impl ::protobuf::Clear for HTTPMatchRequest {
    fn clear(&mut self) {
        self.name.clear();
        self.uri.clear();
        self.scheme.clear();
        self.method.clear();
        self.authority.clear();
        self.headers.clear();
        self.port = 0;
        self.source_labels.clear();
        self.gateways.clear();
        self.query_params.clear();
        self.ignore_uri_case = false;
        self.without_headers.clear();
        self.source_namespace.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HTTPMatchRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HTTPMatchRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct HTTPRouteDestination {
    // message fields
    pub destination: ::protobuf::SingularPtrField<Destination>,
    pub weight: i32,
    pub headers: ::protobuf::SingularPtrField<Headers>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HTTPRouteDestination {
    fn default() -> &'a HTTPRouteDestination {
        <HTTPRouteDestination as ::protobuf::Message>::default_instance()
    }
}

impl HTTPRouteDestination {
    pub fn new() -> HTTPRouteDestination {
        ::std::default::Default::default()
    }

    // .istio.networking.v1beta1.Destination destination = 1;


    pub fn get_destination(&self) -> &Destination {
        self.destination.as_ref().unwrap_or_else(|| <Destination as ::protobuf::Message>::default_instance())
    }
    pub fn clear_destination(&mut self) {
        self.destination.clear();
    }

    pub fn has_destination(&self) -> bool {
        self.destination.is_some()
    }

    // Param is passed by value, moved
    pub fn set_destination(&mut self, v: Destination) {
        self.destination = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_destination(&mut self) -> &mut Destination {
        if self.destination.is_none() {
            self.destination.set_default();
        }
        self.destination.as_mut().unwrap()
    }

    // Take field
    pub fn take_destination(&mut self) -> Destination {
        self.destination.take().unwrap_or_else(|| Destination::new())
    }

    // int32 weight = 2;


    pub fn get_weight(&self) -> i32 {
        self.weight
    }
    pub fn clear_weight(&mut self) {
        self.weight = 0;
    }

    // Param is passed by value, moved
    pub fn set_weight(&mut self, v: i32) {
        self.weight = v;
    }

    // .istio.networking.v1beta1.Headers headers = 7;


    pub fn get_headers(&self) -> &Headers {
        self.headers.as_ref().unwrap_or_else(|| <Headers as ::protobuf::Message>::default_instance())
    }
    pub fn clear_headers(&mut self) {
        self.headers.clear();
    }

    pub fn has_headers(&self) -> bool {
        self.headers.is_some()
    }

    // Param is passed by value, moved
    pub fn set_headers(&mut self, v: Headers) {
        self.headers = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_headers(&mut self) -> &mut Headers {
        if self.headers.is_none() {
            self.headers.set_default();
        }
        self.headers.as_mut().unwrap()
    }

    // Take field
    pub fn take_headers(&mut self) -> Headers {
        self.headers.take().unwrap_or_else(|| Headers::new())
    }
}

impl ::protobuf::Message for HTTPRouteDestination {
    fn is_initialized(&self) -> bool {
        for v in &self.destination {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.headers {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.destination)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.weight = tmp;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.headers)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.destination.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.weight != 0 {
            my_size += ::protobuf::rt::value_size(2, self.weight, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.headers.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.destination.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.weight != 0 {
            os.write_int32(2, self.weight)?;
        }
        if let Some(ref v) = self.headers.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HTTPRouteDestination {
        HTTPRouteDestination::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Destination>>(
                "destination",
                |m: &HTTPRouteDestination| { &m.destination },
                |m: &mut HTTPRouteDestination| { &mut m.destination },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "weight",
                |m: &HTTPRouteDestination| { &m.weight },
                |m: &mut HTTPRouteDestination| { &mut m.weight },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Headers>>(
                "headers",
                |m: &HTTPRouteDestination| { &m.headers },
                |m: &mut HTTPRouteDestination| { &mut m.headers },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<HTTPRouteDestination>(
                "HTTPRouteDestination",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static HTTPRouteDestination {
        static instance: ::protobuf::rt::LazyV2<HTTPRouteDestination> = ::protobuf::rt::LazyV2::INIT;
        instance.get(HTTPRouteDestination::new)
    }
}

impl ::protobuf::Clear for HTTPRouteDestination {
    fn clear(&mut self) {
        self.destination.clear();
        self.weight = 0;
        self.headers.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HTTPRouteDestination {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HTTPRouteDestination {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RouteDestination {
    // message fields
    pub destination: ::protobuf::SingularPtrField<Destination>,
    pub weight: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RouteDestination {
    fn default() -> &'a RouteDestination {
        <RouteDestination as ::protobuf::Message>::default_instance()
    }
}

impl RouteDestination {
    pub fn new() -> RouteDestination {
        ::std::default::Default::default()
    }

    // .istio.networking.v1beta1.Destination destination = 1;


    pub fn get_destination(&self) -> &Destination {
        self.destination.as_ref().unwrap_or_else(|| <Destination as ::protobuf::Message>::default_instance())
    }
    pub fn clear_destination(&mut self) {
        self.destination.clear();
    }

    pub fn has_destination(&self) -> bool {
        self.destination.is_some()
    }

    // Param is passed by value, moved
    pub fn set_destination(&mut self, v: Destination) {
        self.destination = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_destination(&mut self) -> &mut Destination {
        if self.destination.is_none() {
            self.destination.set_default();
        }
        self.destination.as_mut().unwrap()
    }

    // Take field
    pub fn take_destination(&mut self) -> Destination {
        self.destination.take().unwrap_or_else(|| Destination::new())
    }

    // int32 weight = 2;


    pub fn get_weight(&self) -> i32 {
        self.weight
    }
    pub fn clear_weight(&mut self) {
        self.weight = 0;
    }

    // Param is passed by value, moved
    pub fn set_weight(&mut self, v: i32) {
        self.weight = v;
    }
}

impl ::protobuf::Message for RouteDestination {
    fn is_initialized(&self) -> bool {
        for v in &self.destination {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.destination)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.weight = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.destination.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.weight != 0 {
            my_size += ::protobuf::rt::value_size(2, self.weight, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.destination.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.weight != 0 {
            os.write_int32(2, self.weight)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RouteDestination {
        RouteDestination::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Destination>>(
                "destination",
                |m: &RouteDestination| { &m.destination },
                |m: &mut RouteDestination| { &mut m.destination },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "weight",
                |m: &RouteDestination| { &m.weight },
                |m: &mut RouteDestination| { &mut m.weight },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RouteDestination>(
                "RouteDestination",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RouteDestination {
        static instance: ::protobuf::rt::LazyV2<RouteDestination> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RouteDestination::new)
    }
}

impl ::protobuf::Clear for RouteDestination {
    fn clear(&mut self) {
        self.destination.clear();
        self.weight = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RouteDestination {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RouteDestination {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct L4MatchAttributes {
    // message fields
    pub destination_subnets: ::protobuf::RepeatedField<::std::string::String>,
    pub port: u32,
    pub source_subnet: ::std::string::String,
    pub source_labels: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    pub gateways: ::protobuf::RepeatedField<::std::string::String>,
    pub source_namespace: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a L4MatchAttributes {
    fn default() -> &'a L4MatchAttributes {
        <L4MatchAttributes as ::protobuf::Message>::default_instance()
    }
}

impl L4MatchAttributes {
    pub fn new() -> L4MatchAttributes {
        ::std::default::Default::default()
    }

    // repeated string destination_subnets = 1;


    pub fn get_destination_subnets(&self) -> &[::std::string::String] {
        &self.destination_subnets
    }
    pub fn clear_destination_subnets(&mut self) {
        self.destination_subnets.clear();
    }

    // Param is passed by value, moved
    pub fn set_destination_subnets(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.destination_subnets = v;
    }

    // Mutable pointer to the field.
    pub fn mut_destination_subnets(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.destination_subnets
    }

    // Take field
    pub fn take_destination_subnets(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.destination_subnets, ::protobuf::RepeatedField::new())
    }

    // uint32 port = 2;


    pub fn get_port(&self) -> u32 {
        self.port
    }
    pub fn clear_port(&mut self) {
        self.port = 0;
    }

    // Param is passed by value, moved
    pub fn set_port(&mut self, v: u32) {
        self.port = v;
    }

    // string source_subnet = 3;


    pub fn get_source_subnet(&self) -> &str {
        &self.source_subnet
    }
    pub fn clear_source_subnet(&mut self) {
        self.source_subnet.clear();
    }

    // Param is passed by value, moved
    pub fn set_source_subnet(&mut self, v: ::std::string::String) {
        self.source_subnet = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_source_subnet(&mut self) -> &mut ::std::string::String {
        &mut self.source_subnet
    }

    // Take field
    pub fn take_source_subnet(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.source_subnet, ::std::string::String::new())
    }

    // repeated .istio.networking.v1beta1.L4MatchAttributes.SourceLabelsEntry source_labels = 4;


    pub fn get_source_labels(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.source_labels
    }
    pub fn clear_source_labels(&mut self) {
        self.source_labels.clear();
    }

    // Param is passed by value, moved
    pub fn set_source_labels(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.source_labels = v;
    }

    // Mutable pointer to the field.
    pub fn mut_source_labels(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.source_labels
    }

    // Take field
    pub fn take_source_labels(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.source_labels, ::std::collections::HashMap::new())
    }

    // repeated string gateways = 5;


    pub fn get_gateways(&self) -> &[::std::string::String] {
        &self.gateways
    }
    pub fn clear_gateways(&mut self) {
        self.gateways.clear();
    }

    // Param is passed by value, moved
    pub fn set_gateways(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.gateways = v;
    }

    // Mutable pointer to the field.
    pub fn mut_gateways(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.gateways
    }

    // Take field
    pub fn take_gateways(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.gateways, ::protobuf::RepeatedField::new())
    }

    // string source_namespace = 6;


    pub fn get_source_namespace(&self) -> &str {
        &self.source_namespace
    }
    pub fn clear_source_namespace(&mut self) {
        self.source_namespace.clear();
    }

    // Param is passed by value, moved
    pub fn set_source_namespace(&mut self, v: ::std::string::String) {
        self.source_namespace = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_source_namespace(&mut self) -> &mut ::std::string::String {
        &mut self.source_namespace
    }

    // Take field
    pub fn take_source_namespace(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.source_namespace, ::std::string::String::new())
    }
}

impl ::protobuf::Message for L4MatchAttributes {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.destination_subnets)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.port = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.source_subnet)?;
                },
                4 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.source_labels)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.gateways)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.source_namespace)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.destination_subnets {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        if self.port != 0 {
            my_size += ::protobuf::rt::value_size(2, self.port, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.source_subnet.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.source_subnet);
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(4, &self.source_labels);
        for value in &self.gateways {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        if !self.source_namespace.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.source_namespace);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.destination_subnets {
            os.write_string(1, &v)?;
        };
        if self.port != 0 {
            os.write_uint32(2, self.port)?;
        }
        if !self.source_subnet.is_empty() {
            os.write_string(3, &self.source_subnet)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(4, &self.source_labels, os)?;
        for v in &self.gateways {
            os.write_string(5, &v)?;
        };
        if !self.source_namespace.is_empty() {
            os.write_string(6, &self.source_namespace)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> L4MatchAttributes {
        L4MatchAttributes::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "destination_subnets",
                |m: &L4MatchAttributes| { &m.destination_subnets },
                |m: &mut L4MatchAttributes| { &mut m.destination_subnets },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "port",
                |m: &L4MatchAttributes| { &m.port },
                |m: &mut L4MatchAttributes| { &mut m.port },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "source_subnet",
                |m: &L4MatchAttributes| { &m.source_subnet },
                |m: &mut L4MatchAttributes| { &mut m.source_subnet },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                "source_labels",
                |m: &L4MatchAttributes| { &m.source_labels },
                |m: &mut L4MatchAttributes| { &mut m.source_labels },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "gateways",
                |m: &L4MatchAttributes| { &m.gateways },
                |m: &mut L4MatchAttributes| { &mut m.gateways },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "source_namespace",
                |m: &L4MatchAttributes| { &m.source_namespace },
                |m: &mut L4MatchAttributes| { &mut m.source_namespace },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<L4MatchAttributes>(
                "L4MatchAttributes",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static L4MatchAttributes {
        static instance: ::protobuf::rt::LazyV2<L4MatchAttributes> = ::protobuf::rt::LazyV2::INIT;
        instance.get(L4MatchAttributes::new)
    }
}

impl ::protobuf::Clear for L4MatchAttributes {
    fn clear(&mut self) {
        self.destination_subnets.clear();
        self.port = 0;
        self.source_subnet.clear();
        self.source_labels.clear();
        self.gateways.clear();
        self.source_namespace.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for L4MatchAttributes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for L4MatchAttributes {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TLSMatchAttributes {
    // message fields
    pub sni_hosts: ::protobuf::RepeatedField<::std::string::String>,
    pub destination_subnets: ::protobuf::RepeatedField<::std::string::String>,
    pub port: u32,
    pub source_labels: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    pub gateways: ::protobuf::RepeatedField<::std::string::String>,
    pub source_namespace: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TLSMatchAttributes {
    fn default() -> &'a TLSMatchAttributes {
        <TLSMatchAttributes as ::protobuf::Message>::default_instance()
    }
}

impl TLSMatchAttributes {
    pub fn new() -> TLSMatchAttributes {
        ::std::default::Default::default()
    }

    // repeated string sni_hosts = 1;


    pub fn get_sni_hosts(&self) -> &[::std::string::String] {
        &self.sni_hosts
    }
    pub fn clear_sni_hosts(&mut self) {
        self.sni_hosts.clear();
    }

    // Param is passed by value, moved
    pub fn set_sni_hosts(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.sni_hosts = v;
    }

    // Mutable pointer to the field.
    pub fn mut_sni_hosts(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.sni_hosts
    }

    // Take field
    pub fn take_sni_hosts(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.sni_hosts, ::protobuf::RepeatedField::new())
    }

    // repeated string destination_subnets = 2;


    pub fn get_destination_subnets(&self) -> &[::std::string::String] {
        &self.destination_subnets
    }
    pub fn clear_destination_subnets(&mut self) {
        self.destination_subnets.clear();
    }

    // Param is passed by value, moved
    pub fn set_destination_subnets(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.destination_subnets = v;
    }

    // Mutable pointer to the field.
    pub fn mut_destination_subnets(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.destination_subnets
    }

    // Take field
    pub fn take_destination_subnets(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.destination_subnets, ::protobuf::RepeatedField::new())
    }

    // uint32 port = 3;


    pub fn get_port(&self) -> u32 {
        self.port
    }
    pub fn clear_port(&mut self) {
        self.port = 0;
    }

    // Param is passed by value, moved
    pub fn set_port(&mut self, v: u32) {
        self.port = v;
    }

    // repeated .istio.networking.v1beta1.TLSMatchAttributes.SourceLabelsEntry source_labels = 5;


    pub fn get_source_labels(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.source_labels
    }
    pub fn clear_source_labels(&mut self) {
        self.source_labels.clear();
    }

    // Param is passed by value, moved
    pub fn set_source_labels(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.source_labels = v;
    }

    // Mutable pointer to the field.
    pub fn mut_source_labels(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.source_labels
    }

    // Take field
    pub fn take_source_labels(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.source_labels, ::std::collections::HashMap::new())
    }

    // repeated string gateways = 6;


    pub fn get_gateways(&self) -> &[::std::string::String] {
        &self.gateways
    }
    pub fn clear_gateways(&mut self) {
        self.gateways.clear();
    }

    // Param is passed by value, moved
    pub fn set_gateways(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.gateways = v;
    }

    // Mutable pointer to the field.
    pub fn mut_gateways(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.gateways
    }

    // Take field
    pub fn take_gateways(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.gateways, ::protobuf::RepeatedField::new())
    }

    // string source_namespace = 7;


    pub fn get_source_namespace(&self) -> &str {
        &self.source_namespace
    }
    pub fn clear_source_namespace(&mut self) {
        self.source_namespace.clear();
    }

    // Param is passed by value, moved
    pub fn set_source_namespace(&mut self, v: ::std::string::String) {
        self.source_namespace = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_source_namespace(&mut self) -> &mut ::std::string::String {
        &mut self.source_namespace
    }

    // Take field
    pub fn take_source_namespace(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.source_namespace, ::std::string::String::new())
    }
}

impl ::protobuf::Message for TLSMatchAttributes {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.sni_hosts)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.destination_subnets)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.port = tmp;
                },
                5 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.source_labels)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.gateways)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.source_namespace)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.sni_hosts {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in &self.destination_subnets {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        if self.port != 0 {
            my_size += ::protobuf::rt::value_size(3, self.port, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(5, &self.source_labels);
        for value in &self.gateways {
            my_size += ::protobuf::rt::string_size(6, &value);
        };
        if !self.source_namespace.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.source_namespace);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.sni_hosts {
            os.write_string(1, &v)?;
        };
        for v in &self.destination_subnets {
            os.write_string(2, &v)?;
        };
        if self.port != 0 {
            os.write_uint32(3, self.port)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(5, &self.source_labels, os)?;
        for v in &self.gateways {
            os.write_string(6, &v)?;
        };
        if !self.source_namespace.is_empty() {
            os.write_string(7, &self.source_namespace)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TLSMatchAttributes {
        TLSMatchAttributes::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "sni_hosts",
                |m: &TLSMatchAttributes| { &m.sni_hosts },
                |m: &mut TLSMatchAttributes| { &mut m.sni_hosts },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "destination_subnets",
                |m: &TLSMatchAttributes| { &m.destination_subnets },
                |m: &mut TLSMatchAttributes| { &mut m.destination_subnets },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "port",
                |m: &TLSMatchAttributes| { &m.port },
                |m: &mut TLSMatchAttributes| { &mut m.port },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                "source_labels",
                |m: &TLSMatchAttributes| { &m.source_labels },
                |m: &mut TLSMatchAttributes| { &mut m.source_labels },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "gateways",
                |m: &TLSMatchAttributes| { &m.gateways },
                |m: &mut TLSMatchAttributes| { &mut m.gateways },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "source_namespace",
                |m: &TLSMatchAttributes| { &m.source_namespace },
                |m: &mut TLSMatchAttributes| { &mut m.source_namespace },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TLSMatchAttributes>(
                "TLSMatchAttributes",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TLSMatchAttributes {
        static instance: ::protobuf::rt::LazyV2<TLSMatchAttributes> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TLSMatchAttributes::new)
    }
}

impl ::protobuf::Clear for TLSMatchAttributes {
    fn clear(&mut self) {
        self.sni_hosts.clear();
        self.destination_subnets.clear();
        self.port = 0;
        self.source_labels.clear();
        self.gateways.clear();
        self.source_namespace.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TLSMatchAttributes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TLSMatchAttributes {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct HTTPRedirect {
    // message fields
    pub uri: ::std::string::String,
    pub authority: ::std::string::String,
    pub scheme: ::std::string::String,
    pub redirect_code: u32,
    // message oneof groups
    pub redirect_port: ::std::option::Option<HTTPRedirect_oneof_redirect_port>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HTTPRedirect {
    fn default() -> &'a HTTPRedirect {
        <HTTPRedirect as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum HTTPRedirect_oneof_redirect_port {
    port(u32),
    derive_port(HTTPRedirect_RedirectPortSelection),
}

impl HTTPRedirect {
    pub fn new() -> HTTPRedirect {
        ::std::default::Default::default()
    }

    // string uri = 1;


    pub fn get_uri(&self) -> &str {
        &self.uri
    }
    pub fn clear_uri(&mut self) {
        self.uri.clear();
    }

    // Param is passed by value, moved
    pub fn set_uri(&mut self, v: ::std::string::String) {
        self.uri = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_uri(&mut self) -> &mut ::std::string::String {
        &mut self.uri
    }

    // Take field
    pub fn take_uri(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.uri, ::std::string::String::new())
    }

    // string authority = 2;


    pub fn get_authority(&self) -> &str {
        &self.authority
    }
    pub fn clear_authority(&mut self) {
        self.authority.clear();
    }

    // Param is passed by value, moved
    pub fn set_authority(&mut self, v: ::std::string::String) {
        self.authority = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_authority(&mut self) -> &mut ::std::string::String {
        &mut self.authority
    }

    // Take field
    pub fn take_authority(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.authority, ::std::string::String::new())
    }

    // uint32 port = 4;


    pub fn get_port(&self) -> u32 {
        match self.redirect_port {
            ::std::option::Option::Some(HTTPRedirect_oneof_redirect_port::port(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_port(&mut self) {
        self.redirect_port = ::std::option::Option::None;
    }

    pub fn has_port(&self) -> bool {
        match self.redirect_port {
            ::std::option::Option::Some(HTTPRedirect_oneof_redirect_port::port(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_port(&mut self, v: u32) {
        self.redirect_port = ::std::option::Option::Some(HTTPRedirect_oneof_redirect_port::port(v))
    }

    // .istio.networking.v1beta1.HTTPRedirect.RedirectPortSelection derive_port = 5;


    pub fn get_derive_port(&self) -> HTTPRedirect_RedirectPortSelection {
        match self.redirect_port {
            ::std::option::Option::Some(HTTPRedirect_oneof_redirect_port::derive_port(v)) => v,
            _ => HTTPRedirect_RedirectPortSelection::FROM_PROTOCOL_DEFAULT,
        }
    }
    pub fn clear_derive_port(&mut self) {
        self.redirect_port = ::std::option::Option::None;
    }

    pub fn has_derive_port(&self) -> bool {
        match self.redirect_port {
            ::std::option::Option::Some(HTTPRedirect_oneof_redirect_port::derive_port(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_derive_port(&mut self, v: HTTPRedirect_RedirectPortSelection) {
        self.redirect_port = ::std::option::Option::Some(HTTPRedirect_oneof_redirect_port::derive_port(v))
    }

    // string scheme = 6;


    pub fn get_scheme(&self) -> &str {
        &self.scheme
    }
    pub fn clear_scheme(&mut self) {
        self.scheme.clear();
    }

    // Param is passed by value, moved
    pub fn set_scheme(&mut self, v: ::std::string::String) {
        self.scheme = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_scheme(&mut self) -> &mut ::std::string::String {
        &mut self.scheme
    }

    // Take field
    pub fn take_scheme(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.scheme, ::std::string::String::new())
    }

    // uint32 redirect_code = 3;


    pub fn get_redirect_code(&self) -> u32 {
        self.redirect_code
    }
    pub fn clear_redirect_code(&mut self) {
        self.redirect_code = 0;
    }

    // Param is passed by value, moved
    pub fn set_redirect_code(&mut self, v: u32) {
        self.redirect_code = v;
    }
}

impl ::protobuf::Message for HTTPRedirect {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.uri)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.authority)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.redirect_port = ::std::option::Option::Some(HTTPRedirect_oneof_redirect_port::port(is.read_uint32()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.redirect_port = ::std::option::Option::Some(HTTPRedirect_oneof_redirect_port::derive_port(is.read_enum()?));
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.scheme)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.redirect_code = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.uri.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.uri);
        }
        if !self.authority.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.authority);
        }
        if !self.scheme.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.scheme);
        }
        if self.redirect_code != 0 {
            my_size += ::protobuf::rt::value_size(3, self.redirect_code, ::protobuf::wire_format::WireTypeVarint);
        }
        if let ::std::option::Option::Some(ref v) = self.redirect_port {
            match v {
                &HTTPRedirect_oneof_redirect_port::port(v) => {
                    my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
                },
                &HTTPRedirect_oneof_redirect_port::derive_port(v) => {
                    my_size += ::protobuf::rt::enum_size(5, v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.uri.is_empty() {
            os.write_string(1, &self.uri)?;
        }
        if !self.authority.is_empty() {
            os.write_string(2, &self.authority)?;
        }
        if !self.scheme.is_empty() {
            os.write_string(6, &self.scheme)?;
        }
        if self.redirect_code != 0 {
            os.write_uint32(3, self.redirect_code)?;
        }
        if let ::std::option::Option::Some(ref v) = self.redirect_port {
            match v {
                &HTTPRedirect_oneof_redirect_port::port(v) => {
                    os.write_uint32(4, v)?;
                },
                &HTTPRedirect_oneof_redirect_port::derive_port(v) => {
                    os.write_enum(5, ::protobuf::ProtobufEnum::value(&v))?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HTTPRedirect {
        HTTPRedirect::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "uri",
                |m: &HTTPRedirect| { &m.uri },
                |m: &mut HTTPRedirect| { &mut m.uri },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "authority",
                |m: &HTTPRedirect| { &m.authority },
                |m: &mut HTTPRedirect| { &mut m.authority },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor::<_>(
                "port",
                HTTPRedirect::has_port,
                HTTPRedirect::get_port,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_enum_accessor::<_, HTTPRedirect_RedirectPortSelection>(
                "derive_port",
                HTTPRedirect::has_derive_port,
                HTTPRedirect::get_derive_port,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "scheme",
                |m: &HTTPRedirect| { &m.scheme },
                |m: &mut HTTPRedirect| { &mut m.scheme },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "redirect_code",
                |m: &HTTPRedirect| { &m.redirect_code },
                |m: &mut HTTPRedirect| { &mut m.redirect_code },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<HTTPRedirect>(
                "HTTPRedirect",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static HTTPRedirect {
        static instance: ::protobuf::rt::LazyV2<HTTPRedirect> = ::protobuf::rt::LazyV2::INIT;
        instance.get(HTTPRedirect::new)
    }
}

impl ::protobuf::Clear for HTTPRedirect {
    fn clear(&mut self) {
        self.uri.clear();
        self.authority.clear();
        self.redirect_port = ::std::option::Option::None;
        self.redirect_port = ::std::option::Option::None;
        self.scheme.clear();
        self.redirect_code = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HTTPRedirect {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HTTPRedirect {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum HTTPRedirect_RedirectPortSelection {
    FROM_PROTOCOL_DEFAULT = 0,
    FROM_REQUEST_PORT = 1,
}

impl ::protobuf::ProtobufEnum for HTTPRedirect_RedirectPortSelection {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<HTTPRedirect_RedirectPortSelection> {
        match value {
            0 => ::std::option::Option::Some(HTTPRedirect_RedirectPortSelection::FROM_PROTOCOL_DEFAULT),
            1 => ::std::option::Option::Some(HTTPRedirect_RedirectPortSelection::FROM_REQUEST_PORT),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [HTTPRedirect_RedirectPortSelection] = &[
            HTTPRedirect_RedirectPortSelection::FROM_PROTOCOL_DEFAULT,
            HTTPRedirect_RedirectPortSelection::FROM_REQUEST_PORT,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<HTTPRedirect_RedirectPortSelection>("HTTPRedirect.RedirectPortSelection", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for HTTPRedirect_RedirectPortSelection {
}

impl ::std::default::Default for HTTPRedirect_RedirectPortSelection {
    fn default() -> Self {
        HTTPRedirect_RedirectPortSelection::FROM_PROTOCOL_DEFAULT
    }
}

impl ::protobuf::reflect::ProtobufValue for HTTPRedirect_RedirectPortSelection {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct HTTPRewrite {
    // message fields
    pub uri: ::std::string::String,
    pub authority: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HTTPRewrite {
    fn default() -> &'a HTTPRewrite {
        <HTTPRewrite as ::protobuf::Message>::default_instance()
    }
}

impl HTTPRewrite {
    pub fn new() -> HTTPRewrite {
        ::std::default::Default::default()
    }

    // string uri = 1;


    pub fn get_uri(&self) -> &str {
        &self.uri
    }
    pub fn clear_uri(&mut self) {
        self.uri.clear();
    }

    // Param is passed by value, moved
    pub fn set_uri(&mut self, v: ::std::string::String) {
        self.uri = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_uri(&mut self) -> &mut ::std::string::String {
        &mut self.uri
    }

    // Take field
    pub fn take_uri(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.uri, ::std::string::String::new())
    }

    // string authority = 2;


    pub fn get_authority(&self) -> &str {
        &self.authority
    }
    pub fn clear_authority(&mut self) {
        self.authority.clear();
    }

    // Param is passed by value, moved
    pub fn set_authority(&mut self, v: ::std::string::String) {
        self.authority = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_authority(&mut self) -> &mut ::std::string::String {
        &mut self.authority
    }

    // Take field
    pub fn take_authority(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.authority, ::std::string::String::new())
    }
}

impl ::protobuf::Message for HTTPRewrite {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.uri)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.authority)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.uri.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.uri);
        }
        if !self.authority.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.authority);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.uri.is_empty() {
            os.write_string(1, &self.uri)?;
        }
        if !self.authority.is_empty() {
            os.write_string(2, &self.authority)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HTTPRewrite {
        HTTPRewrite::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "uri",
                |m: &HTTPRewrite| { &m.uri },
                |m: &mut HTTPRewrite| { &mut m.uri },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "authority",
                |m: &HTTPRewrite| { &m.authority },
                |m: &mut HTTPRewrite| { &mut m.authority },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<HTTPRewrite>(
                "HTTPRewrite",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static HTTPRewrite {
        static instance: ::protobuf::rt::LazyV2<HTTPRewrite> = ::protobuf::rt::LazyV2::INIT;
        instance.get(HTTPRewrite::new)
    }
}

impl ::protobuf::Clear for HTTPRewrite {
    fn clear(&mut self) {
        self.uri.clear();
        self.authority.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HTTPRewrite {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HTTPRewrite {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StringMatch {
    // message oneof groups
    pub match_type: ::std::option::Option<StringMatch_oneof_match_type>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StringMatch {
    fn default() -> &'a StringMatch {
        <StringMatch as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum StringMatch_oneof_match_type {
    exact(::std::string::String),
    prefix(::std::string::String),
    regex(::std::string::String),
}

impl StringMatch {
    pub fn new() -> StringMatch {
        ::std::default::Default::default()
    }

    // string exact = 1;


    pub fn get_exact(&self) -> &str {
        match self.match_type {
            ::std::option::Option::Some(StringMatch_oneof_match_type::exact(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_exact(&mut self) {
        self.match_type = ::std::option::Option::None;
    }

    pub fn has_exact(&self) -> bool {
        match self.match_type {
            ::std::option::Option::Some(StringMatch_oneof_match_type::exact(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_exact(&mut self, v: ::std::string::String) {
        self.match_type = ::std::option::Option::Some(StringMatch_oneof_match_type::exact(v))
    }

    // Mutable pointer to the field.
    pub fn mut_exact(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(StringMatch_oneof_match_type::exact(_)) = self.match_type {
        } else {
            self.match_type = ::std::option::Option::Some(StringMatch_oneof_match_type::exact(::std::string::String::new()));
        }
        match self.match_type {
            ::std::option::Option::Some(StringMatch_oneof_match_type::exact(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_exact(&mut self) -> ::std::string::String {
        if self.has_exact() {
            match self.match_type.take() {
                ::std::option::Option::Some(StringMatch_oneof_match_type::exact(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // string prefix = 2;


    pub fn get_prefix(&self) -> &str {
        match self.match_type {
            ::std::option::Option::Some(StringMatch_oneof_match_type::prefix(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_prefix(&mut self) {
        self.match_type = ::std::option::Option::None;
    }

    pub fn has_prefix(&self) -> bool {
        match self.match_type {
            ::std::option::Option::Some(StringMatch_oneof_match_type::prefix(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_prefix(&mut self, v: ::std::string::String) {
        self.match_type = ::std::option::Option::Some(StringMatch_oneof_match_type::prefix(v))
    }

    // Mutable pointer to the field.
    pub fn mut_prefix(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(StringMatch_oneof_match_type::prefix(_)) = self.match_type {
        } else {
            self.match_type = ::std::option::Option::Some(StringMatch_oneof_match_type::prefix(::std::string::String::new()));
        }
        match self.match_type {
            ::std::option::Option::Some(StringMatch_oneof_match_type::prefix(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_prefix(&mut self) -> ::std::string::String {
        if self.has_prefix() {
            match self.match_type.take() {
                ::std::option::Option::Some(StringMatch_oneof_match_type::prefix(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // string regex = 3;


    pub fn get_regex(&self) -> &str {
        match self.match_type {
            ::std::option::Option::Some(StringMatch_oneof_match_type::regex(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_regex(&mut self) {
        self.match_type = ::std::option::Option::None;
    }

    pub fn has_regex(&self) -> bool {
        match self.match_type {
            ::std::option::Option::Some(StringMatch_oneof_match_type::regex(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_regex(&mut self, v: ::std::string::String) {
        self.match_type = ::std::option::Option::Some(StringMatch_oneof_match_type::regex(v))
    }

    // Mutable pointer to the field.
    pub fn mut_regex(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(StringMatch_oneof_match_type::regex(_)) = self.match_type {
        } else {
            self.match_type = ::std::option::Option::Some(StringMatch_oneof_match_type::regex(::std::string::String::new()));
        }
        match self.match_type {
            ::std::option::Option::Some(StringMatch_oneof_match_type::regex(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_regex(&mut self) -> ::std::string::String {
        if self.has_regex() {
            match self.match_type.take() {
                ::std::option::Option::Some(StringMatch_oneof_match_type::regex(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }
}

impl ::protobuf::Message for StringMatch {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.match_type = ::std::option::Option::Some(StringMatch_oneof_match_type::exact(is.read_string()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.match_type = ::std::option::Option::Some(StringMatch_oneof_match_type::prefix(is.read_string()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.match_type = ::std::option::Option::Some(StringMatch_oneof_match_type::regex(is.read_string()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.match_type {
            match v {
                &StringMatch_oneof_match_type::exact(ref v) => {
                    my_size += ::protobuf::rt::string_size(1, &v);
                },
                &StringMatch_oneof_match_type::prefix(ref v) => {
                    my_size += ::protobuf::rt::string_size(2, &v);
                },
                &StringMatch_oneof_match_type::regex(ref v) => {
                    my_size += ::protobuf::rt::string_size(3, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.match_type {
            match v {
                &StringMatch_oneof_match_type::exact(ref v) => {
                    os.write_string(1, v)?;
                },
                &StringMatch_oneof_match_type::prefix(ref v) => {
                    os.write_string(2, v)?;
                },
                &StringMatch_oneof_match_type::regex(ref v) => {
                    os.write_string(3, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StringMatch {
        StringMatch::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "exact",
                StringMatch::has_exact,
                StringMatch::get_exact,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "prefix",
                StringMatch::has_prefix,
                StringMatch::get_prefix,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "regex",
                StringMatch::has_regex,
                StringMatch::get_regex,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<StringMatch>(
                "StringMatch",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static StringMatch {
        static instance: ::protobuf::rt::LazyV2<StringMatch> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StringMatch::new)
    }
}

impl ::protobuf::Clear for StringMatch {
    fn clear(&mut self) {
        self.match_type = ::std::option::Option::None;
        self.match_type = ::std::option::Option::None;
        self.match_type = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StringMatch {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StringMatch {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct HTTPRetry {
    // message fields
    pub attempts: i32,
    pub per_try_timeout: ::protobuf::SingularPtrField<::protobuf::well_known_types::Duration>,
    pub retry_on: ::std::string::String,
    pub retry_remote_localities: ::protobuf::SingularPtrField<::protobuf::well_known_types::BoolValue>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HTTPRetry {
    fn default() -> &'a HTTPRetry {
        <HTTPRetry as ::protobuf::Message>::default_instance()
    }
}

impl HTTPRetry {
    pub fn new() -> HTTPRetry {
        ::std::default::Default::default()
    }

    // int32 attempts = 1;


    pub fn get_attempts(&self) -> i32 {
        self.attempts
    }
    pub fn clear_attempts(&mut self) {
        self.attempts = 0;
    }

    // Param is passed by value, moved
    pub fn set_attempts(&mut self, v: i32) {
        self.attempts = v;
    }

    // .google.protobuf.Duration per_try_timeout = 2;


    pub fn get_per_try_timeout(&self) -> &::protobuf::well_known_types::Duration {
        self.per_try_timeout.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Duration as ::protobuf::Message>::default_instance())
    }
    pub fn clear_per_try_timeout(&mut self) {
        self.per_try_timeout.clear();
    }

    pub fn has_per_try_timeout(&self) -> bool {
        self.per_try_timeout.is_some()
    }

    // Param is passed by value, moved
    pub fn set_per_try_timeout(&mut self, v: ::protobuf::well_known_types::Duration) {
        self.per_try_timeout = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_per_try_timeout(&mut self) -> &mut ::protobuf::well_known_types::Duration {
        if self.per_try_timeout.is_none() {
            self.per_try_timeout.set_default();
        }
        self.per_try_timeout.as_mut().unwrap()
    }

    // Take field
    pub fn take_per_try_timeout(&mut self) -> ::protobuf::well_known_types::Duration {
        self.per_try_timeout.take().unwrap_or_else(|| ::protobuf::well_known_types::Duration::new())
    }

    // string retry_on = 3;


    pub fn get_retry_on(&self) -> &str {
        &self.retry_on
    }
    pub fn clear_retry_on(&mut self) {
        self.retry_on.clear();
    }

    // Param is passed by value, moved
    pub fn set_retry_on(&mut self, v: ::std::string::String) {
        self.retry_on = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_retry_on(&mut self) -> &mut ::std::string::String {
        &mut self.retry_on
    }

    // Take field
    pub fn take_retry_on(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.retry_on, ::std::string::String::new())
    }

    // .google.protobuf.BoolValue retry_remote_localities = 4;


    pub fn get_retry_remote_localities(&self) -> &::protobuf::well_known_types::BoolValue {
        self.retry_remote_localities.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::BoolValue as ::protobuf::Message>::default_instance())
    }
    pub fn clear_retry_remote_localities(&mut self) {
        self.retry_remote_localities.clear();
    }

    pub fn has_retry_remote_localities(&self) -> bool {
        self.retry_remote_localities.is_some()
    }

    // Param is passed by value, moved
    pub fn set_retry_remote_localities(&mut self, v: ::protobuf::well_known_types::BoolValue) {
        self.retry_remote_localities = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_retry_remote_localities(&mut self) -> &mut ::protobuf::well_known_types::BoolValue {
        if self.retry_remote_localities.is_none() {
            self.retry_remote_localities.set_default();
        }
        self.retry_remote_localities.as_mut().unwrap()
    }

    // Take field
    pub fn take_retry_remote_localities(&mut self) -> ::protobuf::well_known_types::BoolValue {
        self.retry_remote_localities.take().unwrap_or_else(|| ::protobuf::well_known_types::BoolValue::new())
    }
}

impl ::protobuf::Message for HTTPRetry {
    fn is_initialized(&self) -> bool {
        for v in &self.per_try_timeout {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.retry_remote_localities {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.attempts = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.per_try_timeout)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.retry_on)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.retry_remote_localities)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.attempts != 0 {
            my_size += ::protobuf::rt::value_size(1, self.attempts, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.per_try_timeout.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.retry_on.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.retry_on);
        }
        if let Some(ref v) = self.retry_remote_localities.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.attempts != 0 {
            os.write_int32(1, self.attempts)?;
        }
        if let Some(ref v) = self.per_try_timeout.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.retry_on.is_empty() {
            os.write_string(3, &self.retry_on)?;
        }
        if let Some(ref v) = self.retry_remote_localities.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HTTPRetry {
        HTTPRetry::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "attempts",
                |m: &HTTPRetry| { &m.attempts },
                |m: &mut HTTPRetry| { &mut m.attempts },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Duration>>(
                "per_try_timeout",
                |m: &HTTPRetry| { &m.per_try_timeout },
                |m: &mut HTTPRetry| { &mut m.per_try_timeout },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "retry_on",
                |m: &HTTPRetry| { &m.retry_on },
                |m: &mut HTTPRetry| { &mut m.retry_on },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::BoolValue>>(
                "retry_remote_localities",
                |m: &HTTPRetry| { &m.retry_remote_localities },
                |m: &mut HTTPRetry| { &mut m.retry_remote_localities },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<HTTPRetry>(
                "HTTPRetry",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static HTTPRetry {
        static instance: ::protobuf::rt::LazyV2<HTTPRetry> = ::protobuf::rt::LazyV2::INIT;
        instance.get(HTTPRetry::new)
    }
}

impl ::protobuf::Clear for HTTPRetry {
    fn clear(&mut self) {
        self.attempts = 0;
        self.per_try_timeout.clear();
        self.retry_on.clear();
        self.retry_remote_localities.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HTTPRetry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HTTPRetry {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CorsPolicy {
    // message fields
    pub allow_origin: ::protobuf::RepeatedField<::std::string::String>,
    pub allow_origins: ::protobuf::RepeatedField<StringMatch>,
    pub allow_methods: ::protobuf::RepeatedField<::std::string::String>,
    pub allow_headers: ::protobuf::RepeatedField<::std::string::String>,
    pub expose_headers: ::protobuf::RepeatedField<::std::string::String>,
    pub max_age: ::protobuf::SingularPtrField<::protobuf::well_known_types::Duration>,
    pub allow_credentials: ::protobuf::SingularPtrField<::protobuf::well_known_types::BoolValue>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CorsPolicy {
    fn default() -> &'a CorsPolicy {
        <CorsPolicy as ::protobuf::Message>::default_instance()
    }
}

impl CorsPolicy {
    pub fn new() -> CorsPolicy {
        ::std::default::Default::default()
    }

    // repeated string allow_origin = 1;


    pub fn get_allow_origin(&self) -> &[::std::string::String] {
        &self.allow_origin
    }
    pub fn clear_allow_origin(&mut self) {
        self.allow_origin.clear();
    }

    // Param is passed by value, moved
    pub fn set_allow_origin(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.allow_origin = v;
    }

    // Mutable pointer to the field.
    pub fn mut_allow_origin(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.allow_origin
    }

    // Take field
    pub fn take_allow_origin(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.allow_origin, ::protobuf::RepeatedField::new())
    }

    // repeated .istio.networking.v1beta1.StringMatch allow_origins = 7;


    pub fn get_allow_origins(&self) -> &[StringMatch] {
        &self.allow_origins
    }
    pub fn clear_allow_origins(&mut self) {
        self.allow_origins.clear();
    }

    // Param is passed by value, moved
    pub fn set_allow_origins(&mut self, v: ::protobuf::RepeatedField<StringMatch>) {
        self.allow_origins = v;
    }

    // Mutable pointer to the field.
    pub fn mut_allow_origins(&mut self) -> &mut ::protobuf::RepeatedField<StringMatch> {
        &mut self.allow_origins
    }

    // Take field
    pub fn take_allow_origins(&mut self) -> ::protobuf::RepeatedField<StringMatch> {
        ::std::mem::replace(&mut self.allow_origins, ::protobuf::RepeatedField::new())
    }

    // repeated string allow_methods = 2;


    pub fn get_allow_methods(&self) -> &[::std::string::String] {
        &self.allow_methods
    }
    pub fn clear_allow_methods(&mut self) {
        self.allow_methods.clear();
    }

    // Param is passed by value, moved
    pub fn set_allow_methods(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.allow_methods = v;
    }

    // Mutable pointer to the field.
    pub fn mut_allow_methods(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.allow_methods
    }

    // Take field
    pub fn take_allow_methods(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.allow_methods, ::protobuf::RepeatedField::new())
    }

    // repeated string allow_headers = 3;


    pub fn get_allow_headers(&self) -> &[::std::string::String] {
        &self.allow_headers
    }
    pub fn clear_allow_headers(&mut self) {
        self.allow_headers.clear();
    }

    // Param is passed by value, moved
    pub fn set_allow_headers(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.allow_headers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_allow_headers(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.allow_headers
    }

    // Take field
    pub fn take_allow_headers(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.allow_headers, ::protobuf::RepeatedField::new())
    }

    // repeated string expose_headers = 4;


    pub fn get_expose_headers(&self) -> &[::std::string::String] {
        &self.expose_headers
    }
    pub fn clear_expose_headers(&mut self) {
        self.expose_headers.clear();
    }

    // Param is passed by value, moved
    pub fn set_expose_headers(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.expose_headers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_expose_headers(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.expose_headers
    }

    // Take field
    pub fn take_expose_headers(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.expose_headers, ::protobuf::RepeatedField::new())
    }

    // .google.protobuf.Duration max_age = 5;


    pub fn get_max_age(&self) -> &::protobuf::well_known_types::Duration {
        self.max_age.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Duration as ::protobuf::Message>::default_instance())
    }
    pub fn clear_max_age(&mut self) {
        self.max_age.clear();
    }

    pub fn has_max_age(&self) -> bool {
        self.max_age.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_age(&mut self, v: ::protobuf::well_known_types::Duration) {
        self.max_age = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_max_age(&mut self) -> &mut ::protobuf::well_known_types::Duration {
        if self.max_age.is_none() {
            self.max_age.set_default();
        }
        self.max_age.as_mut().unwrap()
    }

    // Take field
    pub fn take_max_age(&mut self) -> ::protobuf::well_known_types::Duration {
        self.max_age.take().unwrap_or_else(|| ::protobuf::well_known_types::Duration::new())
    }

    // .google.protobuf.BoolValue allow_credentials = 6;


    pub fn get_allow_credentials(&self) -> &::protobuf::well_known_types::BoolValue {
        self.allow_credentials.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::BoolValue as ::protobuf::Message>::default_instance())
    }
    pub fn clear_allow_credentials(&mut self) {
        self.allow_credentials.clear();
    }

    pub fn has_allow_credentials(&self) -> bool {
        self.allow_credentials.is_some()
    }

    // Param is passed by value, moved
    pub fn set_allow_credentials(&mut self, v: ::protobuf::well_known_types::BoolValue) {
        self.allow_credentials = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_allow_credentials(&mut self) -> &mut ::protobuf::well_known_types::BoolValue {
        if self.allow_credentials.is_none() {
            self.allow_credentials.set_default();
        }
        self.allow_credentials.as_mut().unwrap()
    }

    // Take field
    pub fn take_allow_credentials(&mut self) -> ::protobuf::well_known_types::BoolValue {
        self.allow_credentials.take().unwrap_or_else(|| ::protobuf::well_known_types::BoolValue::new())
    }
}

impl ::protobuf::Message for CorsPolicy {
    fn is_initialized(&self) -> bool {
        for v in &self.allow_origins {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.max_age {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.allow_credentials {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.allow_origin)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.allow_origins)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.allow_methods)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.allow_headers)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.expose_headers)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.max_age)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.allow_credentials)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.allow_origin {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in &self.allow_origins {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.allow_methods {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in &self.allow_headers {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        for value in &self.expose_headers {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        if let Some(ref v) = self.max_age.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.allow_credentials.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.allow_origin {
            os.write_string(1, &v)?;
        };
        for v in &self.allow_origins {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.allow_methods {
            os.write_string(2, &v)?;
        };
        for v in &self.allow_headers {
            os.write_string(3, &v)?;
        };
        for v in &self.expose_headers {
            os.write_string(4, &v)?;
        };
        if let Some(ref v) = self.max_age.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.allow_credentials.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CorsPolicy {
        CorsPolicy::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "allow_origin",
                |m: &CorsPolicy| { &m.allow_origin },
                |m: &mut CorsPolicy| { &mut m.allow_origin },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<StringMatch>>(
                "allow_origins",
                |m: &CorsPolicy| { &m.allow_origins },
                |m: &mut CorsPolicy| { &mut m.allow_origins },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "allow_methods",
                |m: &CorsPolicy| { &m.allow_methods },
                |m: &mut CorsPolicy| { &mut m.allow_methods },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "allow_headers",
                |m: &CorsPolicy| { &m.allow_headers },
                |m: &mut CorsPolicy| { &mut m.allow_headers },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "expose_headers",
                |m: &CorsPolicy| { &m.expose_headers },
                |m: &mut CorsPolicy| { &mut m.expose_headers },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Duration>>(
                "max_age",
                |m: &CorsPolicy| { &m.max_age },
                |m: &mut CorsPolicy| { &mut m.max_age },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::BoolValue>>(
                "allow_credentials",
                |m: &CorsPolicy| { &m.allow_credentials },
                |m: &mut CorsPolicy| { &mut m.allow_credentials },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CorsPolicy>(
                "CorsPolicy",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CorsPolicy {
        static instance: ::protobuf::rt::LazyV2<CorsPolicy> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CorsPolicy::new)
    }
}

impl ::protobuf::Clear for CorsPolicy {
    fn clear(&mut self) {
        self.allow_origin.clear();
        self.allow_origins.clear();
        self.allow_methods.clear();
        self.allow_headers.clear();
        self.expose_headers.clear();
        self.max_age.clear();
        self.allow_credentials.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CorsPolicy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CorsPolicy {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct HTTPFaultInjection {
    // message fields
    pub delay: ::protobuf::SingularPtrField<HTTPFaultInjection_Delay>,
    pub abort: ::protobuf::SingularPtrField<HTTPFaultInjection_Abort>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HTTPFaultInjection {
    fn default() -> &'a HTTPFaultInjection {
        <HTTPFaultInjection as ::protobuf::Message>::default_instance()
    }
}

impl HTTPFaultInjection {
    pub fn new() -> HTTPFaultInjection {
        ::std::default::Default::default()
    }

    // .istio.networking.v1beta1.HTTPFaultInjection.Delay delay = 1;


    pub fn get_delay(&self) -> &HTTPFaultInjection_Delay {
        self.delay.as_ref().unwrap_or_else(|| <HTTPFaultInjection_Delay as ::protobuf::Message>::default_instance())
    }
    pub fn clear_delay(&mut self) {
        self.delay.clear();
    }

    pub fn has_delay(&self) -> bool {
        self.delay.is_some()
    }

    // Param is passed by value, moved
    pub fn set_delay(&mut self, v: HTTPFaultInjection_Delay) {
        self.delay = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_delay(&mut self) -> &mut HTTPFaultInjection_Delay {
        if self.delay.is_none() {
            self.delay.set_default();
        }
        self.delay.as_mut().unwrap()
    }

    // Take field
    pub fn take_delay(&mut self) -> HTTPFaultInjection_Delay {
        self.delay.take().unwrap_or_else(|| HTTPFaultInjection_Delay::new())
    }

    // .istio.networking.v1beta1.HTTPFaultInjection.Abort abort = 2;


    pub fn get_abort(&self) -> &HTTPFaultInjection_Abort {
        self.abort.as_ref().unwrap_or_else(|| <HTTPFaultInjection_Abort as ::protobuf::Message>::default_instance())
    }
    pub fn clear_abort(&mut self) {
        self.abort.clear();
    }

    pub fn has_abort(&self) -> bool {
        self.abort.is_some()
    }

    // Param is passed by value, moved
    pub fn set_abort(&mut self, v: HTTPFaultInjection_Abort) {
        self.abort = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_abort(&mut self) -> &mut HTTPFaultInjection_Abort {
        if self.abort.is_none() {
            self.abort.set_default();
        }
        self.abort.as_mut().unwrap()
    }

    // Take field
    pub fn take_abort(&mut self) -> HTTPFaultInjection_Abort {
        self.abort.take().unwrap_or_else(|| HTTPFaultInjection_Abort::new())
    }
}

impl ::protobuf::Message for HTTPFaultInjection {
    fn is_initialized(&self) -> bool {
        for v in &self.delay {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.abort {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.delay)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.abort)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.delay.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.abort.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.delay.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.abort.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HTTPFaultInjection {
        HTTPFaultInjection::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<HTTPFaultInjection_Delay>>(
                "delay",
                |m: &HTTPFaultInjection| { &m.delay },
                |m: &mut HTTPFaultInjection| { &mut m.delay },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<HTTPFaultInjection_Abort>>(
                "abort",
                |m: &HTTPFaultInjection| { &m.abort },
                |m: &mut HTTPFaultInjection| { &mut m.abort },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<HTTPFaultInjection>(
                "HTTPFaultInjection",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static HTTPFaultInjection {
        static instance: ::protobuf::rt::LazyV2<HTTPFaultInjection> = ::protobuf::rt::LazyV2::INIT;
        instance.get(HTTPFaultInjection::new)
    }
}

impl ::protobuf::Clear for HTTPFaultInjection {
    fn clear(&mut self) {
        self.delay.clear();
        self.abort.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HTTPFaultInjection {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HTTPFaultInjection {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct HTTPFaultInjection_Delay {
    // message fields
    pub percent: i32,
    pub percentage: ::protobuf::SingularPtrField<Percent>,
    // message oneof groups
    pub http_delay_type: ::std::option::Option<HTTPFaultInjection_Delay_oneof_http_delay_type>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HTTPFaultInjection_Delay {
    fn default() -> &'a HTTPFaultInjection_Delay {
        <HTTPFaultInjection_Delay as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum HTTPFaultInjection_Delay_oneof_http_delay_type {
    fixed_delay(::protobuf::well_known_types::Duration),
    exponential_delay(::protobuf::well_known_types::Duration),
}

impl HTTPFaultInjection_Delay {
    pub fn new() -> HTTPFaultInjection_Delay {
        ::std::default::Default::default()
    }

    // int32 percent = 1;


    pub fn get_percent(&self) -> i32 {
        self.percent
    }
    pub fn clear_percent(&mut self) {
        self.percent = 0;
    }

    // Param is passed by value, moved
    pub fn set_percent(&mut self, v: i32) {
        self.percent = v;
    }

    // .google.protobuf.Duration fixed_delay = 2;


    pub fn get_fixed_delay(&self) -> &::protobuf::well_known_types::Duration {
        match self.http_delay_type {
            ::std::option::Option::Some(HTTPFaultInjection_Delay_oneof_http_delay_type::fixed_delay(ref v)) => v,
            _ => <::protobuf::well_known_types::Duration as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_fixed_delay(&mut self) {
        self.http_delay_type = ::std::option::Option::None;
    }

    pub fn has_fixed_delay(&self) -> bool {
        match self.http_delay_type {
            ::std::option::Option::Some(HTTPFaultInjection_Delay_oneof_http_delay_type::fixed_delay(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_fixed_delay(&mut self, v: ::protobuf::well_known_types::Duration) {
        self.http_delay_type = ::std::option::Option::Some(HTTPFaultInjection_Delay_oneof_http_delay_type::fixed_delay(v))
    }

    // Mutable pointer to the field.
    pub fn mut_fixed_delay(&mut self) -> &mut ::protobuf::well_known_types::Duration {
        if let ::std::option::Option::Some(HTTPFaultInjection_Delay_oneof_http_delay_type::fixed_delay(_)) = self.http_delay_type {
        } else {
            self.http_delay_type = ::std::option::Option::Some(HTTPFaultInjection_Delay_oneof_http_delay_type::fixed_delay(::protobuf::well_known_types::Duration::new()));
        }
        match self.http_delay_type {
            ::std::option::Option::Some(HTTPFaultInjection_Delay_oneof_http_delay_type::fixed_delay(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_fixed_delay(&mut self) -> ::protobuf::well_known_types::Duration {
        if self.has_fixed_delay() {
            match self.http_delay_type.take() {
                ::std::option::Option::Some(HTTPFaultInjection_Delay_oneof_http_delay_type::fixed_delay(v)) => v,
                _ => panic!(),
            }
        } else {
            ::protobuf::well_known_types::Duration::new()
        }
    }

    // .google.protobuf.Duration exponential_delay = 3;


    pub fn get_exponential_delay(&self) -> &::protobuf::well_known_types::Duration {
        match self.http_delay_type {
            ::std::option::Option::Some(HTTPFaultInjection_Delay_oneof_http_delay_type::exponential_delay(ref v)) => v,
            _ => <::protobuf::well_known_types::Duration as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_exponential_delay(&mut self) {
        self.http_delay_type = ::std::option::Option::None;
    }

    pub fn has_exponential_delay(&self) -> bool {
        match self.http_delay_type {
            ::std::option::Option::Some(HTTPFaultInjection_Delay_oneof_http_delay_type::exponential_delay(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_exponential_delay(&mut self, v: ::protobuf::well_known_types::Duration) {
        self.http_delay_type = ::std::option::Option::Some(HTTPFaultInjection_Delay_oneof_http_delay_type::exponential_delay(v))
    }

    // Mutable pointer to the field.
    pub fn mut_exponential_delay(&mut self) -> &mut ::protobuf::well_known_types::Duration {
        if let ::std::option::Option::Some(HTTPFaultInjection_Delay_oneof_http_delay_type::exponential_delay(_)) = self.http_delay_type {
        } else {
            self.http_delay_type = ::std::option::Option::Some(HTTPFaultInjection_Delay_oneof_http_delay_type::exponential_delay(::protobuf::well_known_types::Duration::new()));
        }
        match self.http_delay_type {
            ::std::option::Option::Some(HTTPFaultInjection_Delay_oneof_http_delay_type::exponential_delay(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_exponential_delay(&mut self) -> ::protobuf::well_known_types::Duration {
        if self.has_exponential_delay() {
            match self.http_delay_type.take() {
                ::std::option::Option::Some(HTTPFaultInjection_Delay_oneof_http_delay_type::exponential_delay(v)) => v,
                _ => panic!(),
            }
        } else {
            ::protobuf::well_known_types::Duration::new()
        }
    }

    // .istio.networking.v1beta1.Percent percentage = 5;


    pub fn get_percentage(&self) -> &Percent {
        self.percentage.as_ref().unwrap_or_else(|| <Percent as ::protobuf::Message>::default_instance())
    }
    pub fn clear_percentage(&mut self) {
        self.percentage.clear();
    }

    pub fn has_percentage(&self) -> bool {
        self.percentage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_percentage(&mut self, v: Percent) {
        self.percentage = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_percentage(&mut self) -> &mut Percent {
        if self.percentage.is_none() {
            self.percentage.set_default();
        }
        self.percentage.as_mut().unwrap()
    }

    // Take field
    pub fn take_percentage(&mut self) -> Percent {
        self.percentage.take().unwrap_or_else(|| Percent::new())
    }
}

impl ::protobuf::Message for HTTPFaultInjection_Delay {
    fn is_initialized(&self) -> bool {
        if let Some(HTTPFaultInjection_Delay_oneof_http_delay_type::fixed_delay(ref v)) = self.http_delay_type {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(HTTPFaultInjection_Delay_oneof_http_delay_type::exponential_delay(ref v)) = self.http_delay_type {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.percentage {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.percent = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.http_delay_type = ::std::option::Option::Some(HTTPFaultInjection_Delay_oneof_http_delay_type::fixed_delay(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.http_delay_type = ::std::option::Option::Some(HTTPFaultInjection_Delay_oneof_http_delay_type::exponential_delay(is.read_message()?));
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.percentage)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.percent != 0 {
            my_size += ::protobuf::rt::value_size(1, self.percent, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.percentage.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let ::std::option::Option::Some(ref v) = self.http_delay_type {
            match v {
                &HTTPFaultInjection_Delay_oneof_http_delay_type::fixed_delay(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &HTTPFaultInjection_Delay_oneof_http_delay_type::exponential_delay(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.percent != 0 {
            os.write_int32(1, self.percent)?;
        }
        if let Some(ref v) = self.percentage.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let ::std::option::Option::Some(ref v) = self.http_delay_type {
            match v {
                &HTTPFaultInjection_Delay_oneof_http_delay_type::fixed_delay(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &HTTPFaultInjection_Delay_oneof_http_delay_type::exponential_delay(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HTTPFaultInjection_Delay {
        HTTPFaultInjection_Delay::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "percent",
                |m: &HTTPFaultInjection_Delay| { &m.percent },
                |m: &mut HTTPFaultInjection_Delay| { &mut m.percent },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ::protobuf::well_known_types::Duration>(
                "fixed_delay",
                HTTPFaultInjection_Delay::has_fixed_delay,
                HTTPFaultInjection_Delay::get_fixed_delay,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ::protobuf::well_known_types::Duration>(
                "exponential_delay",
                HTTPFaultInjection_Delay::has_exponential_delay,
                HTTPFaultInjection_Delay::get_exponential_delay,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Percent>>(
                "percentage",
                |m: &HTTPFaultInjection_Delay| { &m.percentage },
                |m: &mut HTTPFaultInjection_Delay| { &mut m.percentage },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<HTTPFaultInjection_Delay>(
                "HTTPFaultInjection.Delay",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static HTTPFaultInjection_Delay {
        static instance: ::protobuf::rt::LazyV2<HTTPFaultInjection_Delay> = ::protobuf::rt::LazyV2::INIT;
        instance.get(HTTPFaultInjection_Delay::new)
    }
}

impl ::protobuf::Clear for HTTPFaultInjection_Delay {
    fn clear(&mut self) {
        self.percent = 0;
        self.http_delay_type = ::std::option::Option::None;
        self.http_delay_type = ::std::option::Option::None;
        self.percentage.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HTTPFaultInjection_Delay {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HTTPFaultInjection_Delay {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct HTTPFaultInjection_Abort {
    // message fields
    pub percentage: ::protobuf::SingularPtrField<Percent>,
    // message oneof groups
    pub error_type: ::std::option::Option<HTTPFaultInjection_Abort_oneof_error_type>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HTTPFaultInjection_Abort {
    fn default() -> &'a HTTPFaultInjection_Abort {
        <HTTPFaultInjection_Abort as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum HTTPFaultInjection_Abort_oneof_error_type {
    http_status(i32),
    grpc_status(::std::string::String),
    http2_error(::std::string::String),
}

impl HTTPFaultInjection_Abort {
    pub fn new() -> HTTPFaultInjection_Abort {
        ::std::default::Default::default()
    }

    // int32 http_status = 2;


    pub fn get_http_status(&self) -> i32 {
        match self.error_type {
            ::std::option::Option::Some(HTTPFaultInjection_Abort_oneof_error_type::http_status(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_http_status(&mut self) {
        self.error_type = ::std::option::Option::None;
    }

    pub fn has_http_status(&self) -> bool {
        match self.error_type {
            ::std::option::Option::Some(HTTPFaultInjection_Abort_oneof_error_type::http_status(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_http_status(&mut self, v: i32) {
        self.error_type = ::std::option::Option::Some(HTTPFaultInjection_Abort_oneof_error_type::http_status(v))
    }

    // string grpc_status = 3;


    pub fn get_grpc_status(&self) -> &str {
        match self.error_type {
            ::std::option::Option::Some(HTTPFaultInjection_Abort_oneof_error_type::grpc_status(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_grpc_status(&mut self) {
        self.error_type = ::std::option::Option::None;
    }

    pub fn has_grpc_status(&self) -> bool {
        match self.error_type {
            ::std::option::Option::Some(HTTPFaultInjection_Abort_oneof_error_type::grpc_status(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_grpc_status(&mut self, v: ::std::string::String) {
        self.error_type = ::std::option::Option::Some(HTTPFaultInjection_Abort_oneof_error_type::grpc_status(v))
    }

    // Mutable pointer to the field.
    pub fn mut_grpc_status(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(HTTPFaultInjection_Abort_oneof_error_type::grpc_status(_)) = self.error_type {
        } else {
            self.error_type = ::std::option::Option::Some(HTTPFaultInjection_Abort_oneof_error_type::grpc_status(::std::string::String::new()));
        }
        match self.error_type {
            ::std::option::Option::Some(HTTPFaultInjection_Abort_oneof_error_type::grpc_status(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_grpc_status(&mut self) -> ::std::string::String {
        if self.has_grpc_status() {
            match self.error_type.take() {
                ::std::option::Option::Some(HTTPFaultInjection_Abort_oneof_error_type::grpc_status(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // string http2_error = 4;


    pub fn get_http2_error(&self) -> &str {
        match self.error_type {
            ::std::option::Option::Some(HTTPFaultInjection_Abort_oneof_error_type::http2_error(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_http2_error(&mut self) {
        self.error_type = ::std::option::Option::None;
    }

    pub fn has_http2_error(&self) -> bool {
        match self.error_type {
            ::std::option::Option::Some(HTTPFaultInjection_Abort_oneof_error_type::http2_error(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_http2_error(&mut self, v: ::std::string::String) {
        self.error_type = ::std::option::Option::Some(HTTPFaultInjection_Abort_oneof_error_type::http2_error(v))
    }

    // Mutable pointer to the field.
    pub fn mut_http2_error(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(HTTPFaultInjection_Abort_oneof_error_type::http2_error(_)) = self.error_type {
        } else {
            self.error_type = ::std::option::Option::Some(HTTPFaultInjection_Abort_oneof_error_type::http2_error(::std::string::String::new()));
        }
        match self.error_type {
            ::std::option::Option::Some(HTTPFaultInjection_Abort_oneof_error_type::http2_error(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_http2_error(&mut self) -> ::std::string::String {
        if self.has_http2_error() {
            match self.error_type.take() {
                ::std::option::Option::Some(HTTPFaultInjection_Abort_oneof_error_type::http2_error(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // .istio.networking.v1beta1.Percent percentage = 5;


    pub fn get_percentage(&self) -> &Percent {
        self.percentage.as_ref().unwrap_or_else(|| <Percent as ::protobuf::Message>::default_instance())
    }
    pub fn clear_percentage(&mut self) {
        self.percentage.clear();
    }

    pub fn has_percentage(&self) -> bool {
        self.percentage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_percentage(&mut self, v: Percent) {
        self.percentage = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_percentage(&mut self) -> &mut Percent {
        if self.percentage.is_none() {
            self.percentage.set_default();
        }
        self.percentage.as_mut().unwrap()
    }

    // Take field
    pub fn take_percentage(&mut self) -> Percent {
        self.percentage.take().unwrap_or_else(|| Percent::new())
    }
}

impl ::protobuf::Message for HTTPFaultInjection_Abort {
    fn is_initialized(&self) -> bool {
        for v in &self.percentage {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.error_type = ::std::option::Option::Some(HTTPFaultInjection_Abort_oneof_error_type::http_status(is.read_int32()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.error_type = ::std::option::Option::Some(HTTPFaultInjection_Abort_oneof_error_type::grpc_status(is.read_string()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.error_type = ::std::option::Option::Some(HTTPFaultInjection_Abort_oneof_error_type::http2_error(is.read_string()?));
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.percentage)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.percentage.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let ::std::option::Option::Some(ref v) = self.error_type {
            match v {
                &HTTPFaultInjection_Abort_oneof_error_type::http_status(v) => {
                    my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
                },
                &HTTPFaultInjection_Abort_oneof_error_type::grpc_status(ref v) => {
                    my_size += ::protobuf::rt::string_size(3, &v);
                },
                &HTTPFaultInjection_Abort_oneof_error_type::http2_error(ref v) => {
                    my_size += ::protobuf::rt::string_size(4, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.percentage.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let ::std::option::Option::Some(ref v) = self.error_type {
            match v {
                &HTTPFaultInjection_Abort_oneof_error_type::http_status(v) => {
                    os.write_int32(2, v)?;
                },
                &HTTPFaultInjection_Abort_oneof_error_type::grpc_status(ref v) => {
                    os.write_string(3, v)?;
                },
                &HTTPFaultInjection_Abort_oneof_error_type::http2_error(ref v) => {
                    os.write_string(4, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HTTPFaultInjection_Abort {
        HTTPFaultInjection_Abort::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor::<_>(
                "http_status",
                HTTPFaultInjection_Abort::has_http_status,
                HTTPFaultInjection_Abort::get_http_status,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "grpc_status",
                HTTPFaultInjection_Abort::has_grpc_status,
                HTTPFaultInjection_Abort::get_grpc_status,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "http2_error",
                HTTPFaultInjection_Abort::has_http2_error,
                HTTPFaultInjection_Abort::get_http2_error,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Percent>>(
                "percentage",
                |m: &HTTPFaultInjection_Abort| { &m.percentage },
                |m: &mut HTTPFaultInjection_Abort| { &mut m.percentage },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<HTTPFaultInjection_Abort>(
                "HTTPFaultInjection.Abort",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static HTTPFaultInjection_Abort {
        static instance: ::protobuf::rt::LazyV2<HTTPFaultInjection_Abort> = ::protobuf::rt::LazyV2::INIT;
        instance.get(HTTPFaultInjection_Abort::new)
    }
}

impl ::protobuf::Clear for HTTPFaultInjection_Abort {
    fn clear(&mut self) {
        self.error_type = ::std::option::Option::None;
        self.error_type = ::std::option::Option::None;
        self.error_type = ::std::option::Option::None;
        self.percentage.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HTTPFaultInjection_Abort {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HTTPFaultInjection_Abort {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PortSelector {
    // message fields
    pub number: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PortSelector {
    fn default() -> &'a PortSelector {
        <PortSelector as ::protobuf::Message>::default_instance()
    }
}

impl PortSelector {
    pub fn new() -> PortSelector {
        ::std::default::Default::default()
    }

    // uint32 number = 1;


    pub fn get_number(&self) -> u32 {
        self.number
    }
    pub fn clear_number(&mut self) {
        self.number = 0;
    }

    // Param is passed by value, moved
    pub fn set_number(&mut self, v: u32) {
        self.number = v;
    }
}

impl ::protobuf::Message for PortSelector {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.number = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.number != 0 {
            my_size += ::protobuf::rt::value_size(1, self.number, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.number != 0 {
            os.write_uint32(1, self.number)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PortSelector {
        PortSelector::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "number",
                |m: &PortSelector| { &m.number },
                |m: &mut PortSelector| { &mut m.number },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PortSelector>(
                "PortSelector",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PortSelector {
        static instance: ::protobuf::rt::LazyV2<PortSelector> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PortSelector::new)
    }
}

impl ::protobuf::Clear for PortSelector {
    fn clear(&mut self) {
        self.number = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PortSelector {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PortSelector {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Percent {
    // message fields
    pub value: f64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Percent {
    fn default() -> &'a Percent {
        <Percent as ::protobuf::Message>::default_instance()
    }
}

impl Percent {
    pub fn new() -> Percent {
        ::std::default::Default::default()
    }

    // double value = 1;


    pub fn get_value(&self) -> f64 {
        self.value
    }
    pub fn clear_value(&mut self) {
        self.value = 0.;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: f64) {
        self.value = v;
    }
}

impl ::protobuf::Message for Percent {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.value = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != 0. {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.value != 0. {
            os.write_double(1, self.value)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Percent {
        Percent::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "value",
                |m: &Percent| { &m.value },
                |m: &mut Percent| { &mut m.value },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Percent>(
                "Percent",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Percent {
        static instance: ::protobuf::rt::LazyV2<Percent> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Percent::new)
    }
}

impl ::protobuf::Clear for Percent {
    fn clear(&mut self) {
        self.value = 0.;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Percent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Percent {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n(networking/v1beta1/virtual_service.proto\x12\x18istio.networking.v1be\
    ta1\x1a\x1fgoogle/api/field_behavior.proto\x1a\x1egoogle/protobuf/durati\
    on.proto\x1a\x1egoogle/protobuf/wrappers.proto\"\x84\x02\n\x0eVirtualSer\
    vice\x12\x14\n\x05hosts\x18\x01\x20\x03(\tR\x05hosts\x12\x1a\n\x08gatewa\
    ys\x18\x02\x20\x03(\tR\x08gateways\x127\n\x04http\x18\x03\x20\x03(\x0b2#\
    .istio.networking.v1beta1.HTTPRouteR\x04http\x124\n\x03tls\x18\x05\x20\
    \x03(\x0b2\".istio.networking.v1beta1.TLSRouteR\x03tls\x124\n\x03tcp\x18\
    \x04\x20\x03(\x0b2\".istio.networking.v1beta1.TCPRouteR\x03tcp\x12\x1b\n\
    \texport_to\x18\x06\x20\x03(\tR\x08exportTo\"z\n\x0bDestination\x12\x17\
    \n\x04host\x18\x01\x20\x01(\tR\x04hostB\x03\xe0A\x02\x12\x16\n\x06subset\
    \x18\x02\x20\x01(\tR\x06subset\x12:\n\x04port\x18\x03\x20\x01(\x0b2&.ist\
    io.networking.v1beta1.PortSelectorR\x04port\"\x91\x08\n\tHTTPRoute\x12\
    \x12\n\x04name\x18\x11\x20\x01(\tR\x04name\x12@\n\x05match\x18\x01\x20\
    \x03(\x0b2*.istio.networking.v1beta1.HTTPMatchRequestR\x05match\x12D\n\
    \x05route\x18\x02\x20\x03(\x0b2..istio.networking.v1beta1.HTTPRouteDesti\
    nationR\x05route\x12B\n\x08redirect\x18\x03\x20\x01(\x0b2&.istio.network\
    ing.v1beta1.HTTPRedirectR\x08redirect\x12>\n\x08delegate\x18\x14\x20\x01\
    (\x0b2\".istio.networking.v1beta1.DelegateR\x08delegate\x12?\n\x07rewrit\
    e\x18\x04\x20\x01(\x0b2%.istio.networking.v1beta1.HTTPRewriteR\x07rewrit\
    e\x123\n\x07timeout\x18\x06\x20\x01(\x0b2\x19.google.protobuf.DurationR\
    \x07timeout\x12=\n\x07retries\x18\x07\x20\x01(\x0b2#.istio.networking.v1\
    beta1.HTTPRetryR\x07retries\x12B\n\x05fault\x18\x08\x20\x01(\x0b2,.istio\
    .networking.v1beta1.HTTPFaultInjectionR\x05fault\x12=\n\x06mirror\x18\t\
    \x20\x01(\x0b2%.istio.networking.v1beta1.DestinationR\x06mirror\x12G\n\
    \x0emirror_percent\x18\x12\x20\x01(\x0b2\x1c.google.protobuf.UInt32Value\
    R\rmirrorPercentB\x02\x18\x01\x12N\n\x11mirror_percentage\x18\x13\x20\
    \x01(\x0b2!.istio.networking.v1beta1.PercentR\x10mirrorPercentage\x12E\n\
    \x0bcors_policy\x18\n\x20\x01(\x0b2$.istio.networking.v1beta1.CorsPolicy\
    R\ncorsPolicy\x12;\n\x07headers\x18\x10\x20\x01(\x0b2!.istio.networking.\
    v1beta1.HeadersR\x07headersJ\x04\x08\x05\x10\x06J\x04\x08\x0b\x10\x10R\
    \x11websocket_upgradeR\x0eappend_headersR\x17remove_response_headersR\
    \x17append_response_headersR\x16remove_request_headersR\x16append_reques\
    t_headers\"<\n\x08Delegate\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\
    \x12\x1c\n\tnamespace\x18\x02\x20\x01(\tR\tnamespace\"\xe2\x03\n\x07Head\
    ers\x12L\n\x07request\x18\x01\x20\x01(\x0b22.istio.networking.v1beta1.He\
    aders.HeaderOperationsR\x07request\x12N\n\x08response\x18\x02\x20\x01(\
    \x0b22.istio.networking.v1beta1.Headers.HeaderOperationsR\x08response\
    \x1a\xb8\x02\n\x10HeaderOperations\x12M\n\x03set\x18\x01\x20\x03(\x0b2;.\
    istio.networking.v1beta1.Headers.HeaderOperations.SetEntryR\x03set\x12M\
    \n\x03add\x18\x02\x20\x03(\x0b2;.istio.networking.v1beta1.Headers.Header\
    Operations.AddEntryR\x03add\x12\x16\n\x06remove\x18\x03\x20\x03(\tR\x06r\
    emove\x1a6\n\x08SetEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\
    \x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01\x1a6\n\x08AddEntr\
    y\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\
    \x20\x01(\tR\x05value:\x028\x01\"\x95\x01\n\x08TLSRoute\x12G\n\x05match\
    \x18\x01\x20\x03(\x0b2,.istio.networking.v1beta1.TLSMatchAttributesR\x05\
    matchB\x03\xe0A\x02\x12@\n\x05route\x18\x02\x20\x03(\x0b2*.istio.network\
    ing.v1beta1.RouteDestinationR\x05route\"\x8f\x01\n\x08TCPRoute\x12A\n\
    \x05match\x18\x01\x20\x03(\x0b2+.istio.networking.v1beta1.L4MatchAttribu\
    tesR\x05match\x12@\n\x05route\x18\x02\x20\x03(\x0b2*.istio.networking.v1\
    beta1.RouteDestinationR\x05route\"\x99\t\n\x10HTTPMatchRequest\x12\x12\n\
    \x04name\x18\x0b\x20\x01(\tR\x04name\x127\n\x03uri\x18\x01\x20\x01(\x0b2\
    %.istio.networking.v1beta1.StringMatchR\x03uri\x12=\n\x06scheme\x18\x02\
    \x20\x01(\x0b2%.istio.networking.v1beta1.StringMatchR\x06scheme\x12=\n\
    \x06method\x18\x03\x20\x01(\x0b2%.istio.networking.v1beta1.StringMatchR\
    \x06method\x12C\n\tauthority\x18\x04\x20\x01(\x0b2%.istio.networking.v1b\
    eta1.StringMatchR\tauthority\x12Q\n\x07headers\x18\x05\x20\x03(\x0b27.is\
    tio.networking.v1beta1.HTTPMatchRequest.HeadersEntryR\x07headers\x12\x12\
    \n\x04port\x18\x06\x20\x01(\rR\x04port\x12a\n\rsource_labels\x18\x07\x20\
    \x03(\x0b2<.istio.networking.v1beta1.HTTPMatchRequest.SourceLabelsEntryR\
    \x0csourceLabels\x12\x1a\n\x08gateways\x18\x08\x20\x03(\tR\x08gateways\
    \x12^\n\x0cquery_params\x18\t\x20\x03(\x0b2;.istio.networking.v1beta1.HT\
    TPMatchRequest.QueryParamsEntryR\x0bqueryParams\x12&\n\x0fignore_uri_cas\
    e\x18\n\x20\x01(\x08R\rignoreUriCase\x12g\n\x0fwithout_headers\x18\x0c\
    \x20\x03(\x0b2>.istio.networking.v1beta1.HTTPMatchRequest.WithoutHeaders\
    EntryR\x0ewithoutHeaders\x12)\n\x10source_namespace\x18\r\x20\x01(\tR\
    \x0fsourceNamespace\x1aa\n\x0cHeadersEntry\x12\x10\n\x03key\x18\x01\x20\
    \x01(\tR\x03key\x12;\n\x05value\x18\x02\x20\x01(\x0b2%.istio.networking.\
    v1beta1.StringMatchR\x05value:\x028\x01\x1a?\n\x11SourceLabelsEntry\x12\
    \x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\
    \x01(\tR\x05value:\x028\x01\x1ae\n\x10QueryParamsEntry\x12\x10\n\x03key\
    \x18\x01\x20\x01(\tR\x03key\x12;\n\x05value\x18\x02\x20\x01(\x0b2%.istio\
    .networking.v1beta1.StringMatchR\x05value:\x028\x01\x1ah\n\x13WithoutHea\
    dersEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12;\n\x05value\
    \x18\x02\x20\x01(\x0b2%.istio.networking.v1beta1.StringMatchR\x05value:\
    \x028\x01\"\xa1\x02\n\x14HTTPRouteDestination\x12L\n\x0bdestination\x18\
    \x01\x20\x01(\x0b2%.istio.networking.v1beta1.DestinationR\x0bdestination\
    B\x03\xe0A\x02\x12\x16\n\x06weight\x18\x02\x20\x01(\x05R\x06weight\x12;\
    \n\x07headers\x18\x07\x20\x01(\x0b2!.istio.networking.v1beta1.HeadersR\
    \x07headersJ\x04\x08\x03\x10\x07R\x17remove_response_headersR\x17append_\
    response_headersR\x16remove_request_headersR\x16append_request_headers\"\
    x\n\x10RouteDestination\x12L\n\x0bdestination\x18\x01\x20\x01(\x0b2%.ist\
    io.networking.v1beta1.DestinationR\x0bdestinationB\x03\xe0A\x02\x12\x16\
    \n\x06weight\x18\x02\x20\x01(\x05R\x06weight\"\xe9\x02\n\x11L4MatchAttri\
    butes\x12/\n\x13destination_subnets\x18\x01\x20\x03(\tR\x12destinationSu\
    bnets\x12\x12\n\x04port\x18\x02\x20\x01(\rR\x04port\x12#\n\rsource_subne\
    t\x18\x03\x20\x01(\tR\x0csourceSubnet\x12b\n\rsource_labels\x18\x04\x20\
    \x03(\x0b2=.istio.networking.v1beta1.L4MatchAttributes.SourceLabelsEntry\
    R\x0csourceLabels\x12\x1a\n\x08gateways\x18\x05\x20\x03(\tR\x08gateways\
    \x12)\n\x10source_namespace\x18\x06\x20\x01(\tR\x0fsourceNamespace\x1a?\
    \n\x11SourceLabelsEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\
    \x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01\"\xfd\x02\n\x12TL\
    SMatchAttributes\x12\x20\n\tsni_hosts\x18\x01\x20\x03(\tR\x08sniHostsB\
    \x03\xe0A\x02\x12/\n\x13destination_subnets\x18\x02\x20\x03(\tR\x12desti\
    nationSubnets\x12\x12\n\x04port\x18\x03\x20\x01(\rR\x04port\x12c\n\rsour\
    ce_labels\x18\x05\x20\x03(\x0b2>.istio.networking.v1beta1.TLSMatchAttrib\
    utes.SourceLabelsEntryR\x0csourceLabels\x12\x1a\n\x08gateways\x18\x06\
    \x20\x03(\tR\x08gateways\x12)\n\x10source_namespace\x18\x07\x20\x01(\tR\
    \x0fsourceNamespace\x1a?\n\x11SourceLabelsEntry\x12\x10\n\x03key\x18\x01\
    \x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x02\
    8\x01J\x04\x08\x04\x10\x05R\rsource_subnet\"\xce\x02\n\x0cHTTPRedirect\
    \x12\x10\n\x03uri\x18\x01\x20\x01(\tR\x03uri\x12\x1c\n\tauthority\x18\
    \x02\x20\x01(\tR\tauthority\x12\x14\n\x04port\x18\x04\x20\x01(\rH\0R\x04\
    port\x12_\n\x0bderive_port\x18\x05\x20\x01(\x0e2<.istio.networking.v1bet\
    a1.HTTPRedirect.RedirectPortSelectionH\0R\nderivePort\x12\x16\n\x06schem\
    e\x18\x06\x20\x01(\tR\x06scheme\x12#\n\rredirect_code\x18\x03\x20\x01(\r\
    R\x0credirectCode\"I\n\x15RedirectPortSelection\x12\x19\n\x15FROM_PROTOC\
    OL_DEFAULT\x10\0\x12\x15\n\x11FROM_REQUEST_PORT\x10\x01B\x0f\n\rredirect\
    _port\"=\n\x0bHTTPRewrite\x12\x10\n\x03uri\x18\x01\x20\x01(\tR\x03uri\
    \x12\x1c\n\tauthority\x18\x02\x20\x01(\tR\tauthority\"e\n\x0bStringMatch\
    \x12\x16\n\x05exact\x18\x01\x20\x01(\tH\0R\x05exact\x12\x18\n\x06prefix\
    \x18\x02\x20\x01(\tH\0R\x06prefix\x12\x16\n\x05regex\x18\x03\x20\x01(\tH\
    \0R\x05regexB\x0c\n\nmatch_type\"\xde\x01\n\tHTTPRetry\x12\x1f\n\x08atte\
    mpts\x18\x01\x20\x01(\x05R\x08attemptsB\x03\xe0A\x02\x12A\n\x0fper_try_t\
    imeout\x18\x02\x20\x01(\x0b2\x19.google.protobuf.DurationR\rperTryTimeou\
    t\x12\x19\n\x08retry_on\x18\x03\x20\x01(\tR\x07retryOn\x12R\n\x17retry_r\
    emote_localities\x18\x04\x20\x01(\x0b2\x1a.google.protobuf.BoolValueR\
    \x15retryRemoteLocalities\"\xed\x02\n\nCorsPolicy\x12%\n\x0callow_origin\
    \x18\x01\x20\x03(\tR\x0ballowOriginB\x02\x18\x01\x12J\n\rallow_origins\
    \x18\x07\x20\x03(\x0b2%.istio.networking.v1beta1.StringMatchR\x0callowOr\
    igins\x12#\n\rallow_methods\x18\x02\x20\x03(\tR\x0callowMethods\x12#\n\r\
    allow_headers\x18\x03\x20\x03(\tR\x0callowHeaders\x12%\n\x0eexpose_heade\
    rs\x18\x04\x20\x03(\tR\rexposeHeaders\x122\n\x07max_age\x18\x05\x20\x01(\
    \x0b2\x19.google.protobuf.DurationR\x06maxAge\x12G\n\x11allow_credential\
    s\x18\x06\x20\x01(\x0b2\x1a.google.protobuf.BoolValueR\x10allowCredentia\
    ls\"\x8b\x05\n\x12HTTPFaultInjection\x12H\n\x05delay\x18\x01\x20\x01(\
    \x0b22.istio.networking.v1beta1.HTTPFaultInjection.DelayR\x05delay\x12H\
    \n\x05abort\x18\x02\x20\x01(\x0b22.istio.networking.v1beta1.HTTPFaultInj\
    ection.AbortR\x05abort\x1a\x88\x02\n\x05Delay\x12\x1c\n\x07percent\x18\
    \x01\x20\x01(\x05R\x07percentB\x02\x18\x01\x12A\n\x0bfixed_delay\x18\x02\
    \x20\x01(\x0b2\x19.google.protobuf.DurationH\0R\nfixedDelayB\x03\xe0A\
    \x02\x12H\n\x11exponential_delay\x18\x03\x20\x01(\x0b2\x19.google.protob\
    uf.DurationH\0R\x10exponentialDelay\x12A\n\npercentage\x18\x05\x20\x01(\
    \x0b2!.istio.networking.v1beta1.PercentR\npercentageB\x11\n\x0fhttp_dela\
    y_type\x1a\xd5\x01\n\x05Abort\x12&\n\x0bhttp_status\x18\x02\x20\x01(\x05\
    H\0R\nhttpStatusB\x03\xe0A\x02\x12!\n\x0bgrpc_status\x18\x03\x20\x01(\tH\
    \0R\ngrpcStatus\x12!\n\x0bhttp2_error\x18\x04\x20\x01(\tH\0R\nhttp2Error\
    \x12A\n\npercentage\x18\x05\x20\x01(\x0b2!.istio.networking.v1beta1.Perc\
    entR\npercentageB\x0c\n\nerror_typeJ\x04\x08\x01\x10\x02R\x07percent\"2\
    \n\x0cPortSelector\x12\x16\n\x06number\x18\x01\x20\x01(\rR\x06numberJ\
    \x04\x08\x02\x10\x03R\x04name\"\x1f\n\x07Percent\x12\x14\n\x05value\x18\
    \x01\x20\x01(\x01R\x05valueB!Z\x1fistio.io/api/networking/v1beta1b\x06pr\
    oto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
